
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Divide &amp; conquer &#8212; Amanuel&#39;s Notebook</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=87e54e7c" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'computerscience/algorithms/divide_conquer';</script>
    <link rel="icon" href="../../_static/favicon.png"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Dynamic programming" href="dynamic_prog.html" />
    <link rel="prev" title="Number-theoretic algorithms" href="numerical_algos.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
  
    <p class="title logo__title">Amanuel's Notebook</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Introduction
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Physics</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../physics/intro.html">1. Introduction</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../physics/quantum-mechanics/quantum_mechanics.html">2. Quantum Mechanics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/entanglement.html">Entanglement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/density_matrix.html">Density matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/partial_trace.html">Partial trace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/wigner_function.html">Wigner function</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/gaussian_quantum_info.html">Gaussian quantum information</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/homodyne_detection.html">Homodyne detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/photon_number_detection.html">Photon number detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/lindblad_eq.html">Lindblad master equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/cv_qc_examples.html">CV QC simulations</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../physics/classical-mech/classical_mech.html">3. Classical Mechanics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../physics/classical-mech/calc_of_var.html">Calculus of variations</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../physics/e-and-m/e_and_m.html">4. Electricity &amp; Magnetism</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../physics/e-and-m/gauss_law.html">Gauss’s law</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../physics/stat-mech/stat_mech.html">5. Statistical Mechanics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../physics/stat-mech/partition_func.html">Partition function</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/stat-mech/grand_can_ens.html">Grand canonical ensemble</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Mathematics</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../mathematics/intro.html">6. Introduction</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/vector-calc/vector_calc.html">7. Vector Calculus</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/vector-calc/gradient.html">Gradient</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/discrete-math/discrete_math.html">8. Discrete Mathematics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/discrete-math/sets.html">Set theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/discrete-math/relations.html">Relations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/discrete-math/graph_theory.html">Graph theory</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/abstract-algebra/algebra.html">9. Abstract Algebra</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/abstract-algebra/group_theory.html">Group theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/abstract-algebra/representation_theory.html">Representation theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/abstract-algebra/bch.html">Baker–Campbell–Hausdorff formula</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/linear-algebra/linear_algebra.html">10. Linear Algebra</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/linear-algebra/change_basis.html">Change of basis</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/matrix-calc/matrix_calc.html">11. Matrix Calculus</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/matrix-calc/vec_mat_deriv.html">Vector and matrix derivatives</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/stoc-calc/stoc_calc.html">12. Stochastic Calculus</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/stoc-calc/stoc_diff_eq.html">Stochastic differential equations</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/differential-equations/diff_eq.html">13. Differential Equations</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/differential-equations/wave_eq.html">Wave equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/differential-equations/laplace_eq.html">Lapalace’s equation</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/complex-analysis/complex_analysis.html">14. Complex Analysis</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/complex-analysis/contour_int.html">Contour integration</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/probability/probability.html">15. Probability Theory</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/probability/conditioning.html">Conditional distributions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/probability/joint.html">Joint distributions</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Computer Science</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">16. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data_structs.html">17. Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lazy_eval.html">18. Lazy Evaluation</a></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="algorithms.html">19. Algorithms</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="numerical_algos.html">Number-theoretic algorithms</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Divide &amp; conquer</a></li>
<li class="toctree-l2"><a class="reference internal" href="dynamic_prog.html">Dynamic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="graph_algos.html">Graph algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="greedy_algos.html">Greedy algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="np_problems.html">Computational complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="linear_prog.html">Linear programming</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../optimization/optimization.html">20. Optimization</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../optimization/semidef_prog.html">Semidefinite programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../optimization/quad_prog.html">Quadratic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../optimization/bayes_opt.html">Bayesian optimization</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../machine-learning/machine_learning.html">21. Machine Learning</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/lin_reg.html">Linear regression</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/tree_based.html">Tree-based models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/boosting.html">Boosting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/kernel_machines.html">Kernel machines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/discriminative.html">Discriminative models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/generative.html">Generative models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/performance_metrics.html">Performance metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/loss_funcs.html">Loss functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/attention.html">Attention</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/physical_learning.html">Physical learning</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../deep-learning/deep_learning.html">22. Deep Learning</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../deep-learning/conv_net.html">Convolutional neural network</a></li>
<li class="toctree-l2"><a class="reference internal" href="../deep-learning/rnn.html">Recurrent neural network</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../reinforcement-learning/reinforcement_learning.html">23. Reinforcement Learning</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../reinforcement-learning/ppo.html">Proximal policy optimization</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../quantum-comp/quantum_comp.html">24. Quantum Computing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../quantum-comp/bern_vazirani.html">Bernstein–Vazirani algorithm</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Statistics</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../statistics/intro.html">25. Introduction</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../statistics/classic-stats/classic_stats.html">26. Classical Statistics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/classic-stats/conf_int.html">Confidence intervals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/classic-stats/pca.html">Principal component analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/classic-stats/bootstrap.html">Bootstrapping</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../statistics/hypo-testing/hypo_testing.html">27. Hypothesis Testing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/hypo-testing/1_samp_t_test.html">One sample <span class="math notranslate nohighlight">\(t\)</span>-test</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../statistics/sampling/sampling_methods.html">28. Sampling Methods</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/sampling/inv_trans_sampling.html">Inverse transform sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/sampling/rejection_sampling.html">Rejection sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/sampling/mcmc.html">Markov chain monte carlo</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../statistics/high-dim-stats/high_dim.html">29. High-Dimensional Statistics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/high-dim-stats/robust_pca.html">Robust principal component analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/high-dim-stats/compress_sense.html">Compressed sensing</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../statistics/bayesian-statistics/bayesian_statistics.html">30. Bayesian Statistics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/bayesian-statistics/cred_int.html">Credible interval</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/bayesian-statistics/hierarchical_models.html">Hierarchical models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/bayesian-statistics/missing_data.html">Missing data</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Back Matter</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../backmatter/bibliography.html">31. Bibliography</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/amanuelanteneh/aman-notes" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/amanuelanteneh/aman-notes/issues/new?title=Issue%20on%20page%20%2Fcomputerscience/algorithms/divide_conquer.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/computerscience/algorithms/divide_conquer.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Divide & conquer</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#binary-search">Binary search</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#integer-multiplication">Integer multiplication</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-recurrence-relations">Solving recurrence relations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#substitution">Substitution</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recursion-tree">Recursion-tree</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#master-method">Master method</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#square-matrix-multiplication">Square matrix multiplication</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#naive-matrix-multiplication">Naive matrix multiplication</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#strassens-algorithm">Strassen’s algorithm</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#merge-sort">Merge sort</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#medians">Medians</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#randomized-divide-conquer">Randomized divide &amp; conquer</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tighter-bound">Tighter bound</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#median-of-medians">Median of medians</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#proof-of-good-pivot-selection">Proof of good pivot selection</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#quicksort">Quicksort</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#fast-fourier-transform">Fast Fourier transform</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#background">Background</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#representations-of-polynomials">Representations of polynomials</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#coefficient-representation">Coefficient representation</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#value-representation">Value representation</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#naive-transformation">Naive transformation</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-the-set-x">Choosing the set <span class="math notranslate nohighlight">\(X\)</span></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#complex-numbers">Complex numbers</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#roots-of-unity">Roots of unity</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#practice-problems">Practice problems</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">2.2</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">2.4</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">2.5</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">2.6</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sum-of-n-th-roots-of-unity">2.7 Sum of <span class="math notranslate nohighlight">\(n\)</span>-th roots of unity</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">2.12</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#removing-duplicates">2.14 Removing duplicates</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#in-place-split">2.15 In-place split</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-i-i">2.17 <span class="math notranslate nohighlight">\(A[i]=i\)</span></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">2.18</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id20">2.19</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id21">2.20</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#selection-with-two-sorted-lists">2.22 Selection with two sorted lists</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="divide-conquer">
<h1>Divide &amp; conquer<a class="headerlink" href="#divide-conquer" title="Link to this heading">#</a></h1>
<p>Divide &amp; conquer is a method for designing algorithms that solve problems by breaking the problem into smaller subproblems and then solving those smaller problems by dividing further until some base case is reached when the problem is small enough. Once the base case is reached we solve that subproblem and then use that solution to solve the larger problem by combining it with solutions to the other smaller subproblems we have solved. Merge sort is a nice example of this that we will go over. As you can probably guess from this description divide &amp; conquer is very closely tied to the concept of recursion.</p>
<section id="binary-search">
<h2>Binary search<a class="headerlink" href="#binary-search" title="Link to this heading">#</a></h2>
<p>Perhaps the simplest example of a divide and conquer algorithm is binary search. The algorithm solves the following problem: Given a <em>sorted</em> (ascending order) list of numbers <span class="math notranslate nohighlight">\(A\)</span> of size <span class="math notranslate nohighlight">\(n\)</span> how quickly can we determine of an arbitrary target value <span class="math notranslate nohighlight">\(t\)</span> is in the list and find its position in the list? The algorithm is given below.</p>
<div class="proof algorithm dropdown admonition" id="bin-search">
<p class="admonition-title"><span class="caption-number">Algorithm 19.3 </span> (Binary Search)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>procedure</strong> <span class="math notranslate nohighlight">\(\text{binary_search}(A,t)\)</span>:</p>
<p><strong>Inputs</strong> Given a list of <span class="math notranslate nohighlight">\(A[1,...,n]\)</span> and a target <span class="math notranslate nohighlight">\(t\)</span></p>
<p><strong>Output</strong> The position of <span class="math notranslate nohighlight">\(t\)</span> in the list if it exists in the list</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(L = 1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(R = n\)</span></p></li>
<li><p>while <span class="math notranslate nohighlight">\(L\leq R\)</span>:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(m = \lfloor\frac{L+R}{2}\rfloor\)</span></p></li>
<li><p>if <span class="math notranslate nohighlight">\(A[m]&lt;t\)</span>:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(L=m+1\)</span></p></li>
</ol>
</li>
<li><p>else if <span class="math notranslate nohighlight">\(A[m]&gt;t\)</span>:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(R=m-1\)</span></p></li>
</ol>
</li>
<li><p>else if <span class="math notranslate nohighlight">\(A[m]=t\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(m\)</span></p></li>
</ol>
</li>
</ol>
</li>
<li><p>return unsuccessful</p></li>
</ol>
</section>
</div><p>At each iteration we are checking the value in the value in the middle of the list to see if it is greater than, equal to or less than <span class="math notranslate nohighlight">\(t\)</span>. If the value is equal to <span class="math notranslate nohighlight">\(t\)</span> then we are done. If the value is greater than <span class="math notranslate nohighlight">\(t\)</span> then we update the iteration to only look at the elements in the list that come before the middle value. Why? Because the list is sorted in ascending order if the middle element is greater than <span class="math notranslate nohighlight">\(t\)</span> then we <em>know</em> all values that come after the middle element will also be greater than <span class="math notranslate nohighlight">\(t\)</span> since they must be equal to or greater than the middle element. The same logic applied in the case where the middle element is less than <span class="math notranslate nohighlight">\(t\)</span> except in that case in the next iteration we look at only the elements that come <em>after</em> the middle element.</p>
<p>What is the time complexity of this algorithm? Well during each iteration we just compare two numbers which takes <span class="math notranslate nohighlight">\(O(1)\)</span> time. But how many iterations, or recursion calls if we implement this with recursion, will we have to compute before we finish? Well the algorithm terminates when we have only 1 item left in the list and since we remove half the elements in the list at each iteration we need to simply answer: how many times do we need to divide <span class="math notranslate nohighlight">\(n\)</span> by <span class="math notranslate nohighlight">\(2\)</span> before we reach <span class="math notranslate nohighlight">\(1\)</span>? The simple algebriac equation that descirbes this is given by</p>
<div class="math notranslate nohighlight">
\[
\frac{n}{2^x} = 1
\]</div>
<p>solving this for <span class="math notranslate nohighlight">\(x\)</span> yields <span class="math notranslate nohighlight">\(x=\log_2{n}\)</span> so in the worse case where the element is not in the list we must complete <span class="math notranslate nohighlight">\(\log_2{n}\)</span> iterations. So the time complexity of binary search is <span class="math notranslate nohighlight">\(O(\log_2{n})\)</span> which is incredibly efficient.</p>
<p>Alternatively if we had implemented this algorithm using recursion then the time complexity for solving a problem of size <span class="math notranslate nohighlight">\(n\)</span> would be described by the recurrence relation</p>
<div class="math notranslate nohighlight">
\[
T(n) = T\left(\frac{n}{2}\right) + O(1)
\]</div>
<p>which can be read as saying: to solve a problem of size <span class="math notranslate nohighlight">\(n\)</span> requires we perform a constant number of operations, which is captured by the <span class="math notranslate nohighlight">\(O(1)\)</span>, as well as solve a <em>single</em> problem of half the size which is captured by the <span class="math notranslate nohighlight">\(T\left(\frac{n}{2}\right)\)</span>.</p>
</section>
<section id="integer-multiplication">
<h2>Integer multiplication<a class="headerlink" href="#integer-multiplication" title="Link to this heading">#</a></h2>
<p>The first problem divide &amp; conquer methods are applied to in <span id="id1">[<a class="reference internal" href="../../backmatter/bibliography.html#id29" title="Sanjoy Dasgupta, Christos H Papadimitriou, and Umesh Virkumar Vazirani. Algorithms. McGraw-Hill Higher Education New York, 2008.">Dasgupta <em>et al.</em>, 2008</a>]</span> is integer multiplication.</p>
<p>To multiple two complex numbers <span class="math notranslate nohighlight">\(g=a+ib\)</span> and <span class="math notranslate nohighlight">\(h=c+id\)</span> we compute</p>
<div class="math notranslate nohighlight">
\[
(a+ib)(c+id)= ac-bd + (bc+ad)i
\]</div>
<p>which involves 4 multiplications of real numbers. Carl Gauss, the famous mathematician, discovered that we can actually reduce this to 3 since</p>
<div class="math notranslate nohighlight">
\[
bc+ad = (a+b)(c+d) - ac - bd
\]</div>
<p>our formula now becomes</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
(a+ib)(c+id) &amp;= ac-bd + (bc+ad)i \\
&amp;= ac-bd + ((a+b)(c+d) - ac - bd)i.
\end{align*}
\end{split}\]</div>
<p>It seems like this involves more multiplication but actually we now just need to compute <span class="math notranslate nohighlight">\(ac\)</span>, <span class="math notranslate nohighlight">\(bd\)</span> and <span class="math notranslate nohighlight">\((a+b)(c+d)\)</span> since <span class="math notranslate nohighlight">\(ac\)</span> and <span class="math notranslate nohighlight">\(bd\)</span> appear twice in the expression so we have 3 <em>unique</em> multiplications of real numbers.</p>
<p>This might seem like minimal improvement but lets see what happens when we apply recursion and switch to integer multiplication. Suppose <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(x\)</span> are <span class="math notranslate nohighlight">\(n\)</span>-bit integers where <span class="math notranslate nohighlight">\(n\)</span> is a power of 2. First lets start by splitting <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> into two halves that are <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span> bits each such that</p>
<div class="math notranslate nohighlight">
\[
x = 2^{\frac{n}{2}} x_L + x_R \quad \text{ and } \quad y = 2^{\frac{n}{2}} y_L + y_R.
\]</div>
<p>For example if  <span class="math notranslate nohighlight">\(x=10110110_2\)</span> then <span class="math notranslate nohighlight">\(x_L=1011_2\)</span> and <span class="math notranslate nohighlight">\(x_R=0110_2\)</span> and <span class="math notranslate nohighlight">\(x=(2^{\frac{n}{2}} \times 1011_2) + 0110_2\)</span>, (note the subscript of 2 means the number is written in base 2 i.e. binary).</p>
<div class="dropdown admonition note">
<p class="admonition-title">Note</p>
<p>Note that we multiply the left most bits by <span class="math notranslate nohighlight">\(2^{n/2}\)</span> since these are the <span class="math notranslate nohighlight">\(n/2\)</span> most significant bits since we’re using big endian convention.
As an explicit example for the <span class="math notranslate nohighlight">\(8\)</span>-bit number</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
x &amp;= 182_{10}\\
&amp;=10110110_2 \\ 
&amp;= (1\times2^7)+(0\times2^6)+(1\times2^5)+(1\times2^4)+(0\times2^3)+(1\times2^2)+(1\times2^1)+(0\times2^0)
\end{align*}
\end{split}\]</div>
<p>since the leftmost bits are the most significant we must have <span class="math notranslate nohighlight">\(x_L=2^{4}\times1011_2 =2^{\frac{8}{2}}\left[(1\times2^3)+(0\times2^2)+(1\times2^1)+(1\times2^0)\right]\)</span> if we are to have <span class="math notranslate nohighlight">\(x_R=0110_2\)</span> and satisfy the equation <span class="math notranslate nohighlight">\(x_L+x_R=x\)</span>.</p>
</div>
<p>Now the product of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
xy &amp;= (2^{\frac{n}{2}} x_L + x_R)(2^{\frac{n}{2}} y_L + y_R)  \\
   &amp;= 2^nx_Ly_L + 2^{\frac{n}{2}}(x_Ly_R + x_Ry_L) + x_Ry_R
\end{align*}
\end{split}\]</div>
<p>The addition will take linear time, in the number of bits, and so to will the power of 2 multiplications since it is just a bit shift to the left i.e. <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;&lt;</span> <span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;&lt;</span> <span class="pre">n_2</span></code> in  <code class="docutils literal notranslate"><span class="pre">Python</span></code>. The important operation are the 4 multiplications of the <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span>-bit numbers. Notice that we have <em>divided</em> the problem into 4 subproblems each of which are <em>half</em> the size i.e. <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span>. We can now recursively perform the same routine for the 4 new multiplications which would further divide the problem into subproblem of smaller size.
We can describe the runtime (time complexity) of these recursive algorithms using <em>recurrence relations</em> which we cover in the next section. The recurrence relation for this algorithm is given by</p>
<div class="math notranslate nohighlight">
\[
T(n) = 4T\left(\frac{n}{2}\right) + O(n)
\]</div>
<p>we multiply by 4 since we are creating 4 new subproblems and multiple by <span class="math notranslate nohighlight">\(T\left(\frac{n}{2}\right)\)</span> since the new subproblems have size <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span>. The additional <span class="math notranslate nohighlight">\(O(n)\)</span> is there to capture the linear time complexity of additions and leftward bit shifts. Solving this recurrence relation for <span class="math notranslate nohighlight">\(T(n)\)</span> we get the solution is <span class="math notranslate nohighlight">\(T(n)=O(n^2)\)</span>. This is the same complexity as the grade-school multiplication method so we have no real improvement with this new recursive algorithm.</p>
<p>We can improve this algorithm by using the insight from Gauss that we laid out earlier. Since <span class="math notranslate nohighlight">\(x_Ly_R + x_Ry_L=(x_L+x_R)(y_L+y_R)-x_Ly_L-x_Ry_R\)</span> we can reduce the 4 multiplications needed down to 3 resulting in a more efficient algorithm.</p>
<p>The pseudocode and for the algorithm are given below.</p>
<div class="proof algorithm dropdown admonition" id="gauss-int-mult">
<p class="admonition-title"><span class="caption-number">Algorithm 19.4 </span> (Integer Multiplication)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>procedure</strong> <span class="math notranslate nohighlight">\(\text{fast_int_mult}(x,y,n)\)</span>:</p>
<p><strong>Inputs</strong> Given <span class="math notranslate nohighlight">\(n\)</span>-bit integers <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span></p>
<p><strong>Output</strong> Their integer product <span class="math notranslate nohighlight">\(xy\)</span></p>
<ol class="arabic simple">
<li><p>if <span class="math notranslate nohighlight">\(n=1\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(xy\)</span></p></li>
</ol>
</li>
<li><p><span class="math notranslate nohighlight">\(x_L = \text{ leftmost } \lceil \frac{n}{2} \rceil \text{ bits of } x\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(x_R = \text{ rightmost } \lfloor \frac{n}{2} \rfloor \text{ bits of } x\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(y_L = \text{ leftmost } \lceil \frac{n}{2} \rceil \text{ bits of } y\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(y_R = \text{ rightmost } \lfloor \frac{n}{2} \rfloor \text{ bits of } y\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(P_1 = \text{fast_int_mult}(x_L,y_L)\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Compute <span class="math notranslate nohighlight">\(x_Ly_L\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(P_2 = \text{fast_int_mult}(x_R,y_R)\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Compute <span class="math notranslate nohighlight">\(x_Ry_R\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(P_3 = \text{fast_int_mult}(x_L+x_R,y_L+y_R)\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Compute <span class="math notranslate nohighlight">\((x_L+x_R)(y_L+y_R)\)</span></p></li>
<li><p>return <span class="math notranslate nohighlight">\(2^{n} P_1 + 2^{n}(P_3 - P_1 - P_2) + P_2\)</span></p></li>
</ol>
</section>
</div><p>The time complexity for this algorithm is given by the recurrence relation</p>
<div class="math notranslate nohighlight">
\[
T(n) = 3T\left(\frac{n}{2}\right) + O(n)
\]</div>
<p>which has the solution <span class="math notranslate nohighlight">\(T(n) = O(n^{1.59})\)</span> which is a very nice improvement.</p>
</section>
<section id="solving-recurrence-relations">
<h2>Solving recurrence relations<a class="headerlink" href="#solving-recurrence-relations" title="Link to this heading">#</a></h2>
<p>A recurrence relation, which we’ll call recurrence for short from now on, is an equation that describes a function in terms of it’s values on other, usually smaller, arguments. To solve these recurrences there are three main methods described below <span id="id2">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span>.</p>
<section id="substitution">
<h3>Substitution<a class="headerlink" href="#substitution" title="Link to this heading">#</a></h3>
<p>Given a recursion based algorithm we guess the solution and use induction to prove it is correct. For example for the recurrence relation</p>
<div class="math notranslate nohighlight">
\[
T(n) = T\left(\frac{4n}{5}\right) + O(n)
\]</div>
</section>
<section id="recursion-tree">
<h3>Recursion-tree<a class="headerlink" href="#recursion-tree" title="Link to this heading">#</a></h3>
<p>Given a recursion based algorithm you draw out a the recursion as a tree with with the number of branches at each node being the number of subproblems being created, the depth being the levels of recursion and the nodes of the tree representing the cost of an operation at that level of recursion. By examining the tree you then attempt to write out the expression for the time complexity by summing up the nodes.</p>
</section>
<section id="master-method">
<h3>Master method<a class="headerlink" href="#master-method" title="Link to this heading">#</a></h3>
<p>Given a recursion based algorithm if we can express it’s runtime as a recurrence of the form</p>
<div class="math notranslate nohighlight">
\[
T(n) = aT\left(\left\lceil\frac{n}{b}\right\rceil\right) + O(n^d)
\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is the size of the initial problem, <span class="math notranslate nohighlight">\(a\)</span> is the number of subproblems that we divide the problem into at each recursion level, <span class="math notranslate nohighlight">\(\frac{n}{b}\)</span> is the size of the subproblems and <span class="math notranslate nohighlight">\(O(n^d)\)</span> is the time needed to combine the solutions of said subproblems into solutions for the larger problems we can use the <em>master theorem</em> to solve the recurrence.</p>
<div class="proof theorem admonition" id="theorem-2">
<p class="admonition-title"><span class="caption-number">Theorem 19.2 </span> (Master Theorem)</p>
<section class="theorem-content" id="proof-content">
<p>Given the recurrence</p>
<div class="math notranslate nohighlight">
\[
T(n) = aT\left(\left\lceil\frac{n}{b}\right\rceil\right) + O(n^d)
\]</div>
<p>the solution <span class="math notranslate nohighlight">\(T(n)\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}
T(n) = \begin{cases}
  O(n^d)  &amp; \text{if } d &gt; \log_b(a)\\
  O(n^d\log(n))  &amp; \text{if } d = \log_b(a)\\
  O(n^{\log_b(a)})  &amp; \text{if } d &lt; \log_b(a)\\
\end{cases}
\end{split}\]</div>
<p>which is very useful. The proof along with the theorem is given in <span id="id3">[<a class="reference internal" href="../../backmatter/bibliography.html#id29" title="Sanjoy Dasgupta, Christos H Papadimitriou, and Umesh Virkumar Vazirani. Algorithms. McGraw-Hill Higher Education New York, 2008.">Dasgupta <em>et al.</em>, 2008</a>]</span>.</p>
</section>
</div></section>
</section>
<section id="square-matrix-multiplication">
<h2>Square matrix multiplication<a class="headerlink" href="#square-matrix-multiplication" title="Link to this heading">#</a></h2>
<section id="naive-matrix-multiplication">
<h3>Naive matrix multiplication<a class="headerlink" href="#naive-matrix-multiplication" title="Link to this heading">#</a></h3>
<p>Let’s go over an example from <span id="id4">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span> now. Let <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> be <span class="math notranslate nohighlight">\(n\times n\)</span> matrices. Their product <span class="math notranslate nohighlight">\(C=AB\)</span> is given by (recall that this is equivalent to taking the dot product between the rows of <span class="math notranslate nohighlight">\(A\)</span> with the columns of <span class="math notranslate nohighlight">\(B\)</span>)</p>
<div class="math notranslate nohighlight">
\[
C_{ij} = \sum_{k=1}^{n} A_{ik}B_{kj}
\]</div>
<p>where <span class="math notranslate nohighlight">\(C_{ij}\)</span> is the element of matrix <span class="math notranslate nohighlight">\(C\)</span> at row <span class="math notranslate nohighlight">\(i\)</span> column <span class="math notranslate nohighlight">\(j\)</span>. The pseudocode for an algorithm that computes this formula is given below.</p>
<p>From the triply nested for-loops we can tell the runtime of this algorithm will be <span class="math notranslate nohighlight">\(\Theta(n^3)\)</span>, since for <span class="math notranslate nohighlight">\(n\)</span> iterations we are performing <span class="math notranslate nohighlight">\(n\)</span> operations <span class="math notranslate nohighlight">\(n\)</span> times.</p>
<p>We can however apply the divide and conquer method to this problem by utilizing <em>matrix partitioning</em>. Recall that for two <span class="math notranslate nohighlight">\(n\times n\)</span> matrices <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>, if <span class="math notranslate nohighlight">\(n\)</span> is even, we can partition the matrices as</p>
<div class="math notranslate nohighlight">
\[\begin{split}
A = \begin{bmatrix}
A_{11} &amp; A_{12}\\
A_{21} &amp; A_{22}
\end{bmatrix} 
\text{ and } 
B = \begin{bmatrix}
B_{11} &amp; B_{12}\\
B_{21} &amp; B_{22}
\end{bmatrix} 
\end{split}\]</div>
<p>where the blocks <span class="math notranslate nohighlight">\(A_{ij}\)</span> and <span class="math notranslate nohighlight">\(B_{ij}\)</span> are simply four <span class="math notranslate nohighlight">\(\frac{n}{2} \times \frac{n}{2}\)</span> square block submatrices. We can now express the matrix product in terms of the standard matrices product formula except this time we treat the block matrices as scalars in a sense</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
AB &amp;= \begin{bmatrix}
A_{11} &amp; A_{12}\\
A_{21} &amp; A_{22}
\end{bmatrix}
\begin{bmatrix}
B_{11} &amp; B_{12}\\
B_{21} &amp; B_{22} 
\end{bmatrix} \\
&amp;= \begin{bmatrix}
A_{11}B_{11} + A_{12}B_{21} &amp;  A_{11}B_{12} + A_{12}B_{22} \\
A_{21}B_{11} + A_{22}B_{21} &amp; A_{21}B_{12} + A_{22}B_{22} 
\end{bmatrix}.
\end{align*}
\end{split}\]</div>
<p>Now we can begin to see how divide and conquer can be applied. Notice that we now have 4 smaller problems now i.e. computing the 4 expressions</p>
<div class="math notranslate nohighlight">
\[\begin{split}
C_{11} = A_{11}B_{11} + A_{12}B_{21}\\
C_{12} = A_{11}B_{12} + A_{12}B_{22}\\
C_{21} = A_{21}B_{11} + A_{22}B_{21}\\
C_{22} = A_{21}B_{12} + A_{22}B_{22} 
\end{split}\]</div>
<p>which involve 4 addition and 8 multiplication of <em>smaller</em> matrices now i.e. matrices of size <span class="math notranslate nohighlight">\(\frac{n}{2}\times \frac{n}{2}\)</span>. The divide and conquer algorithm is given below along with a python implementation of it.</p>
<div class="proof algorithm dropdown admonition" id="naive-mat-mult">
<p class="admonition-title"><span class="caption-number">Algorithm 19.5 </span> (Naive Matrix Multiplication)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>procedure</strong> <span class="math notranslate nohighlight">\(\text{naive_mat_mult}(A,B)\)</span>:</p>
<p><strong>Inputs</strong> Given two <span class="math notranslate nohighlight">\(n\times n\)</span> matrices <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span></p>
<p><strong>Output</strong> Their matrix product <span class="math notranslate nohighlight">\(C=AB\)</span></p>
<ol class="arabic simple">
<li><p>Initialize <span class="math notranslate nohighlight">\(C\)</span> to an all zeros matrix of size <span class="math notranslate nohighlight">\(n\times n\)</span></p></li>
<li><p>for <span class="math notranslate nohighlight">\(i=0\)</span> to <span class="math notranslate nohighlight">\(n\)</span>:</p>
<ol class="arabic simple">
<li><p>for <span class="math notranslate nohighlight">\(j=0\)</span> to <span class="math notranslate nohighlight">\(n\)</span>:</p>
<ol class="arabic simple">
<li><p>for <span class="math notranslate nohighlight">\(k=0\)</span> to <span class="math notranslate nohighlight">\(n\)</span>:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(C[i][j] = C[i][j] + A[i][k] \times B[k][j]\)</span></p></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>return <span class="math notranslate nohighlight">\(C\)</span></p></li>
</ol>
</section>
</div><div class="proof algorithm dropdown admonition" id="d&amp;c-mat-mult">
<p class="admonition-title"><span class="caption-number">Algorithm 19.6 </span> (D&amp;C Matrix Multiplication)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>procedure</strong> <span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A,B,C, n)\)</span>:</p>
<p><strong>Inputs</strong> Given two <span class="math notranslate nohighlight">\(n\times n\)</span> matrices <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> and an all zeros matrix of size <span class="math notranslate nohighlight">\(n\times n\)</span></p>
<p><strong>Output</strong> Their matrix product <span class="math notranslate nohighlight">\(C=AB\)</span></p>
<ol class="arabic simple">
<li><p>if <span class="math notranslate nohighlight">\(n=1\)</span>:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(C[0][0] = C[0][0] + A[0][0]\times B[0][0]\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> These are simply scalars since <span class="math notranslate nohighlight">\(n=1\)</span></p></li>
</ol>
</li>
<li><p>Partition <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(C\)</span> into the 12 <span class="math notranslate nohighlight">\(\frac{n}{2}\times \frac{n}{2}\)</span> matrices <span class="math notranslate nohighlight">\(A_{11},A_{21},A_{21},A_{22},B_{11},B_{21},B_{21},B_{22},C_{11},C_{12},C_{21}\)</span> and <span class="math notranslate nohighlight">\(C_{22}\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Divide step</p></li>
<li><p><span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A_{11},B_{11},C_{11}, \frac{n}{2})\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> This computes <span class="math notranslate nohighlight">\(A_{11}B_{11}\)</span> from <span class="math notranslate nohighlight">\(C_{11} = A_{11}B_{11} + A_{12}B_{21}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A_{12},B_{21},C_{11}, \frac{n}{2})\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> This computes <span class="math notranslate nohighlight">\(A_{12}B_{21}\)</span> from <span class="math notranslate nohighlight">\(C_{11} = A_{11}B_{11} + A_{12}B_{21}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A_{11},B_{12},C_{12}, \frac{n}{2})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A_{12},B_{22},C_{12}, \frac{n}{2})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A_{21},B_{11},C_{21}, \frac{n}{2})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A_{22},B_{21},C_{21}, \frac{n}{2})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A_{21},B_{12},C_{22}, \frac{n}{2})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A_{22},B_{22},C_{22}, \frac{n}{2})\)</span></p></li>
</ol>
</section>
</div><div class="cell tag_hide-input tag_hide-output docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input above-output-prompt docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dc_mat_mult</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
       <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
       <span class="k">return</span> <span class="n">C</span>

    <span class="n">n_2</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">A11</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">]</span>
    <span class="n">A12</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">,</span> <span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
    <span class="n">A21</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">]</span>
    <span class="n">A22</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>

    <span class="n">B11</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">]</span>
    <span class="n">B12</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">,</span> <span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
    <span class="n">B21</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">]</span>
    <span class="n">B22</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>

    <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A11</span><span class="p">,</span> <span class="n">B11</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">],</span> <span class="n">n_2</span><span class="p">)</span>
    <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A12</span><span class="p">,</span> <span class="n">B21</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">],</span> <span class="n">n_2</span><span class="p">)</span>
    <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A11</span><span class="p">,</span> <span class="n">B12</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">,</span> <span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">n_2</span><span class="p">)</span>
    <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A12</span><span class="p">,</span> <span class="n">B22</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">,</span> <span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">n_2</span><span class="p">)</span>
    <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A21</span><span class="p">,</span> <span class="n">B11</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">],</span> <span class="n">n_2</span><span class="p">)</span>
    <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A22</span><span class="p">,</span> <span class="n">B21</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">],</span> <span class="n">n_2</span><span class="p">)</span>
    <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A21</span><span class="p">,</span> <span class="n">B12</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">n_2</span><span class="p">)</span>
    <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A22</span><span class="p">,</span> <span class="n">B22</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">n_2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">C</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">6</span> <span class="c1"># size of matrix</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

<span class="n">AB</span> <span class="o">=</span> <span class="n">A</span><span class="nd">@B</span> <span class="c1"># compute product with numpy</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="c1"># compute product with our algo</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Are the matrices the same?&quot;</span><span class="p">,</span> <span class="s2">&quot;Yes&quot;</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">AB</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;No&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
<details class="hide below-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell output</span>
<span class="expanded">Hide code cell output</span>
</summary>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Are the matrices the same? Yes
</pre></div>
</div>
</div>
</details>
</div>
<p>Now since we divide the problem into 8 subproblems at each recursion (the 8 matrix multiplications of the submatrices) of size <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span> and the operation of partitioning the matrices can be made to have complexity <span class="math notranslate nohighlight">\(O(1)\)</span> if we just keep track of the indices of the submatrices we are working with, instead of creating a whole new set of matrices in memory each time we partition a matrix into blocks which has complexity <span class="math notranslate nohighlight">\(O(n^2)\)</span>, we can characterize the runtime of this algorithm with the recurrence</p>
<div class="math notranslate nohighlight">
\[
T(n) = 8T\left(\frac{n}{2}\right) + O(1).
\]</div>
<p>Using the master theorem we have the solution of this recurrence is <span class="math notranslate nohighlight">\(O(n^3)\)</span> so not an asymptotic improvement over the naive method but a useful example of how to use divide and conquer to solve this problem. There is, however, a divide and conquer algorithm for matrix multiplication, devised by Volker Strassen, that is more clever and has better a runtime.</p>
</section>
<section id="strassens-algorithm">
<h3>Strassen’s algorithm<a class="headerlink" href="#strassens-algorithm" title="Link to this heading">#</a></h3>
<p>Strassen’s algorithm achieves a speed up over both the prior methods by utilizing a clever trick akin to the one found by Gauss for integer multiplication. Specifically the algorithm reduces the number of matrix multiplications that need to be computed at each recursion level from 8 to 7! This is done by computing the product as <span id="id5">[<a class="reference internal" href="../../backmatter/bibliography.html#id29" title="Sanjoy Dasgupta, Christos H Papadimitriou, and Umesh Virkumar Vazirani. Algorithms. McGraw-Hill Higher Education New York, 2008.">Dasgupta <em>et al.</em>, 2008</a>]</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}
AB = \begin{bmatrix}
P_5 + P_4 - P_2 + P_6 &amp; P_1 + P_2\\
P_3 + P_4 &amp; P_1 + P_5 - P_3 - P_7
\end{bmatrix}
\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
&amp;P_1=A_{11}(B_{12} - B_{22}), \qquad P_2=(A_{11} + A_{12})B_{22}, \\
&amp;P_3=(A_{21}+A_{22})B_{11}, \qquad P_4=A_{22}(B_{21}+B_{22}), \\
&amp;P_5=(A_{11}+A_{22})(B_{11}+B_{22}), \qquad P_6=(A_{12}-A_{22})(B_{21}+B_{22})\\
&amp;P_7=(A_{11}-A_{21})(B_{11}+B_{12}).
\end{align*}
\end{split}\]</div>
<p>The recurrence for this algorithms time complexity is now given by</p>
<div class="math notranslate nohighlight">
\[
T(n) = 7T\left(\frac{n}{2}\right) + O(1).
\]</div>
<p>and from the master theorem we get the solution to this recurrence is <span class="math notranslate nohighlight">\(T(n)=O(n^{log_{2}(7)}) \approx O(n^{2.807})\)</span>. This may not seem like a huge improvement but as the matrix sizes get large e.g. in the millions, which is this very common for computations in fields such as deep learning, this algorithms runtime is about an order of magnitude faster. This is, to my knowledge as of writing in 2024, the fastest <em>practical</em> matrix multiplication algorithm. There are other algorithms that are asymptotically faster such as the Coppersmith–Winograd algorithm with a time complexity of <span class="math notranslate nohighlight">\(O(n^{2.373})\)</span> but these are not nearly as practical as they are what are known as <a class="reference external" href="https://en.wikipedia.org/wiki/Galactic_algorithm">galactic algorithms</a>.</p>
</section>
</section>
<section id="merge-sort">
<h2>Merge sort<a class="headerlink" href="#merge-sort" title="Link to this heading">#</a></h2>
<p>Merge sort is one of the best divide and conquer algorithms for sorting a list of numbers. The idea behind merge sort is you have a list <span class="math notranslate nohighlight">\(L\)</span> of numbers and you go about sorting it by first dividing the list into two halves of equal length. We then recursively sort each half of the list and then merge the two sorted lists. The merge sort algorithm is given below.</p>
<div class="proof algorithm dropdown admonition" id="merge-sort">
<p class="admonition-title"><span class="caption-number">Algorithm 19.7 </span> (Merge sort)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>procedure</strong> <span class="math notranslate nohighlight">\(\text{merge_sort}(L)\)</span>:</p>
<p><strong>Inputs</strong> Given a list <span class="math notranslate nohighlight">\(L[1,...,n]\)</span> of length <span class="math notranslate nohighlight">\(n\)</span></p>
<p><strong>Output</strong> The sorted list <span class="math notranslate nohighlight">\(L\)</span> in ascending order</p>
<ol class="arabic simple">
<li><p>if <span class="math notranslate nohighlight">\(n&gt;1\)</span>: <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Divide <span class="math notranslate nohighlight">\(L\)</span> into two smaller lists</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(L_1  = L\left[1,...,\lfloor\frac{n}{2}\rfloor\right]\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Get first <span class="math notranslate nohighlight">\(\lfloor\frac{n}{2}\rfloor\)</span> elements</p></li>
<li><p><span class="math notranslate nohighlight">\(L_2  = L\left[\lfloor\frac{n}{2}\rfloor+1,...,n\right]\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Get last <span class="math notranslate nohighlight">\(\lfloor\frac{n}{2}\rfloor\)</span> elements</p></li>
<li><p>return <span class="math notranslate nohighlight">\(\text{merge}( \text{merge_sort}(L_1),  \text{ merge_sort}(L_2) )\)</span></p></li>
</ol>
</li>
<li><p>else: <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> When list has only 1 element return the element</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(L[1]\)</span></p></li>
</ol>
</li>
</ol>
<p><strong>procedure</strong> <span class="math notranslate nohighlight">\(\text{merge}(L_1, L_2)\)</span>:</p>
<p><strong>Inputs</strong> Given 2 lists <span class="math notranslate nohighlight">\(L_1[1,...,n]\)</span> and <span class="math notranslate nohighlight">\(L_2[1,...,m]\)</span> of length <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(m\)</span> respectively sorted in ascending order.</p>
<p><strong>Output</strong> The  combined list <span class="math notranslate nohighlight">\(L\)</span> sorted in ascending order</p>
<ol class="arabic simple">
<li><p>if <span class="math notranslate nohighlight">\(n=0\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(L_2[1,...,m]\)</span></p></li>
</ol>
</li>
<li><p>if <span class="math notranslate nohighlight">\(m=0\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(L_1[1,...,n]\)</span></p></li>
</ol>
</li>
<li><p>if <span class="math notranslate nohighlight">\(L_1[1] \leq L_2[1]\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(L_1[1] \oplus \text{merge}(L_1[2,...,n], L_2[1,...,m])\)</span></p></li>
</ol>
</li>
<li><p>else:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(L_2[1] \oplus \text{merge}(L_2[1,...,n], L_2[2,...,m])\)</span></p></li>
</ol>
</li>
</ol>
<p>Note <span class="math notranslate nohighlight">\(L_1[1] \oplus \text{merge}(L_1[2,...,n], L_2[1,...,m])\)</span> means we concatenate the list returned from the <span class="math notranslate nohighlight">\(\text{merge}\)</span> call to the end of the one element list <span class="math notranslate nohighlight">\(L_1[1]\)</span>.</p>
</section>
</div><p>Now the <span class="math notranslate nohighlight">\(\text{merge}\)</span> function is the crucial component here as it defines how we combine the resulting sorted lists. Let’s think about how we would combine two sorted (ascending order) lists <span class="math notranslate nohighlight">\(L_1\)</span> and <span class="math notranslate nohighlight">\(L_2\)</span> into a list <span class="math notranslate nohighlight">\(L\)</span>. Well since both lists are sorted when now that the first element of the combined list will either be the first element of <span class="math notranslate nohighlight">\(L_1\)</span> or the first element of <span class="math notranslate nohighlight">\(L_2\)</span>. But why are we assuming the lists are sorted? It isn’t super clear where the lists are getting sorted in the first place. So the key thing to think about is the case where <span class="math notranslate nohighlight">\(\text{merge_sort}\)</span>’s base case is reached. When this happens we just return a a list with one element. Once this happens we start to recurse back up the recursion tree. So the <span class="math notranslate nohighlight">\(\text{merge}\)</span> function is called with the input lists being single element lists. At that point we just compare the elements in both lists and concatenate them based on which is smaller as is done by the last two conditional statements in the <span class="math notranslate nohighlight">\(\text{merge}\)</span> function. After this we move up one level in the recursion tree <span class="math notranslate nohighlight">\(\text{merge}\)</span> is called again but this time the lists have length 2. So we can see that once we get to the top of the recursion tree we will have two list whose sizes, <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(m\)</span> respectively, add up to the size adds up to the length of the original input list. Clearly the <span class="math notranslate nohighlight">\(\text{merge}\)</span> function compares the first element of <span class="math notranslate nohighlight">\(L_1\)</span> with the first element of <span class="math notranslate nohighlight">\(L_2\)</span> and then compares the second element of <span class="math notranslate nohighlight">\(L_1\)</span> with the second element of <span class="math notranslate nohighlight">\(L_2\)</span> and so on. This means <span class="math notranslate nohighlight">\(\text{merge}\)</span> does <span class="math notranslate nohighlight">\(O(n+m)\)</span> operations meaning the time for the merge step is linear in the size of the two lists. So we take a problem of size <span class="math notranslate nohighlight">\(n\)</span> and divide it into two subproblems of size <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span> and solve each of these subproblems in time <span class="math notranslate nohighlight">\(O(n)\)</span> thus the runtime of merge sort is characterized by the recurrence</p>
<div class="math notranslate nohighlight">
\[
T(n) = 2T\left(\frac{n}{2}\right) + O(n)
\]</div>
<p>from the master theorem we have that the solution to this recurrence is <span class="math notranslate nohighlight">\(T(n)=O(n\log(n))\)</span> which means we can sort a list in time that is log-linear in the size of the list. Not bad and in fact this is, provably, the best we can do for a <em>comparison based</em> sorting algorithm <span id="id6">[<a class="reference internal" href="../../backmatter/bibliography.html#id29" title="Sanjoy Dasgupta, Christos H Papadimitriou, and Umesh Virkumar Vazirani. Algorithms. McGraw-Hill Higher Education New York, 2008.">Dasgupta <em>et al.</em>, 2008</a>]</span>. See radix sort for a non-comparison based sorting algorithm with complexity <span class="math notranslate nohighlight">\(O(n)\)</span> <span id="id7">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span>.</p>
</section>
<section id="medians">
<h2>Medians<a class="headerlink" href="#medians" title="Link to this heading">#</a></h2>
<p>We will now look at how to find the median of a list of <em>unsorted</em> (unsorted because if the list was sorted the problem would be trivial) numbers using the divide &amp; conquer method. The median of a set of numbers is of course the number that is smaller than 50% of the numbers in the list and greater than or equal to the other 50% of the numbers in the list. To devise an algorithm for this problem it is actually useful to generalize it. The median, for a list of size <span class="math notranslate nohighlight">\(n\)</span>, can also be thought of as the <span class="math notranslate nohighlight">\(\lfloor\frac{n}{2}\rfloor\)</span>-th smallest number in the list. So perhaps we should generalize this problem into finding the <span class="math notranslate nohighlight">\(k\)</span>-th smallest number in a list of numbers and we’ll call this problem <em>selection</em>.</p>
<section id="randomized-divide-conquer">
<h3>Randomized divide &amp; conquer<a class="headerlink" href="#randomized-divide-conquer" title="Link to this heading">#</a></h3>
<p>So how can we devise an algorithm to find the <span class="math notranslate nohighlight">\(k\)</span>-th smallest number in an unsorted list <span class="math notranslate nohighlight">\(L\)</span>? Suppose we take a number <span class="math notranslate nohighlight">\(w\)</span> and split <span class="math notranslate nohighlight">\(L\)</span> into 3 lists: <span class="math notranslate nohighlight">\(L_l\)</span> which is the list of elements in <span class="math notranslate nohighlight">\(L\)</span> that are less than <span class="math notranslate nohighlight">\(w\)</span>, <span class="math notranslate nohighlight">\(L_w\)</span> the list of elements in <span class="math notranslate nohighlight">\(L\)</span> that are equal to <span class="math notranslate nohighlight">\(w\)</span> and <span class="math notranslate nohighlight">\(L_g\)</span> which is the list of elements in <span class="math notranslate nohighlight">\(L\)</span> that are greater than <span class="math notranslate nohighlight">\(w\)</span>. As an example lets take the following list</p>
<div class="math notranslate nohighlight">
\[
L = [2, 36, 5, 21, 8, 13, 11, 20, 5, 4, 1]
\]</div>
<p>and take <span class="math notranslate nohighlight">\(w=5\)</span>. We would then split the list into</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
L_l &amp;= [2, 4, 1] \\ L_w &amp;= [5,5] \\ L_g &amp;= [36, 21, 8, 13, 11, 20].
\end{align*}
\end{split}\]</div>
<p>Now suppose we want the 8th smallest element of <span class="math notranslate nohighlight">\(L\)</span>. We know that this would be the 3rd smallest element of <span class="math notranslate nohighlight">\(L_g\)</span>. Why? Think of it like this: Where is the smallest element? Well it’s certainly in <span class="math notranslate nohighlight">\(L_l\)</span> since that is the list with all elements smaller than <span class="math notranslate nohighlight">\(w\)</span>. Where is the second smallest element? Also in <span class="math notranslate nohighlight">\(L_l\)</span>. The third smallest element is also in <span class="math notranslate nohighlight">\(L_l\)</span>. Now what about the fourth smallest? Well that would be in <span class="math notranslate nohighlight">\(L_w\)</span> since the first 3 smallest elements are in <span class="math notranslate nohighlight">\(L_l\)</span>. What about the sixth smallest element? Well it can’t be in <span class="math notranslate nohighlight">\(L_l\)</span> since that contains the first 3 smallest, and it can’t be in <span class="math notranslate nohighlight">\(L_w\)</span> since that contains the next 2 smallest so it must be in <span class="math notranslate nohighlight">\(L_g\)</span>, and more importantly it will be the smallest number in <span class="math notranslate nohighlight">\(L_g\)</span>. The seventh smallest number can be found in the same way except this time it will be the <em>second</em> smallest element in <span class="math notranslate nohighlight">\(L_g\)</span>. So to put it in general terms if we want the <span class="math notranslate nohighlight">\(k\)</span>-th smallest element if <span class="math notranslate nohighlight">\(k \leq |L_l|\)</span> then we know the <span class="math notranslate nohighlight">\(k\)</span>-th smallest element is in <span class="math notranslate nohighlight">\(L_l\)</span> and we can simply ignore the other two list. If <span class="math notranslate nohighlight">\(k &gt; |L_l|+|L_w|\)</span> then we know the <span class="math notranslate nohighlight">\(k\)</span>-th smallest element is in <span class="math notranslate nohighlight">\(L_g\)</span>. And if neither condition is true then that means <span class="math notranslate nohighlight">\(|L_s|&lt;k\leq |L_l|+|L_w|\)</span> which means the element we want is in <span class="math notranslate nohighlight">\(L_w\)</span> i.e. the element is <span class="math notranslate nohighlight">\(w\)</span> itself. The pseudocode is given below.</p>
<div class="proof algorithm dropdown admonition" id="selection (Linear Expected Case Time)">
<p class="admonition-title"><span class="caption-number">Algorithm 19.8 </span> (Selection - <span class="math notranslate nohighlight">\(O(n)\)</span> Expected Case Time)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>procedure</strong> <span class="math notranslate nohighlight">\(\text{selection}(L, k)\)</span>:</p>
<p><strong>Inputs</strong> Given a list <span class="math notranslate nohighlight">\(L[1,...,n]\)</span> of length <span class="math notranslate nohighlight">\(n\)</span> and an integer <span class="math notranslate nohighlight">\(1\leq k \leq n\)</span></p>
<p><strong>Output</strong> The <span class="math notranslate nohighlight">\(k\)</span>-th smallest element in the list</p>
<ol class="arabic simple">
<li><p>Select pivot element <span class="math notranslate nohighlight">\(w\)</span> by randomly sampling uniformly from <span class="math notranslate nohighlight">\(L\)</span></p></li>
<li><p>Divide <span class="math notranslate nohighlight">\(L\)</span> into the lists <span class="math notranslate nohighlight">\(L_l\)</span>, <span class="math notranslate nohighlight">\(L_w\)</span> and <span class="math notranslate nohighlight">\(L_g\)</span></p></li>
<li><p>if <span class="math notranslate nohighlight">\(k \leq |L_l|\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(\text{selection}(L_l, k)\)</span></p></li>
</ol>
</li>
<li><p>if <span class="math notranslate nohighlight">\(k &gt; |L_l| + |L_w|\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(\text{selection}(L_g, k-|L_l| - |L_w|)\)</span></p></li>
</ol>
</li>
<li><p>else:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(w\)</span></p></li>
</ol>
</li>
</ol>
</section>
</div><p>Now what about the time complexity of this algorithm? Well if we assume that the size of <span class="math notranslate nohighlight">\(L_l\)</span> and <span class="math notranslate nohighlight">\(L_g\)</span> are roughly equal to <span class="math notranslate nohighlight">\(\frac{1}{2}|L|\)</span> at each divide step then we are dividing the problem into a subproblem of half the size <em>but</em> we must note that the process of splitting the list into the three sublists takes linear time in the number of elements since we must compare each of the <span class="math notranslate nohighlight">\(n\)</span> elements with <span class="math notranslate nohighlight">\(w\)</span> to decide which list it should go into. So the recurrence for this algorithm is given by</p>
<div class="math notranslate nohighlight">
\[
T(n) = T\left(\frac{n}{2}\right) + O(n)
\]</div>
<p>which from the master theorem has the solution <span class="math notranslate nohighlight">\(O(n)\)</span>! This is a great solution but it relies on a rather strong assumption: that we choose a value of <span class="math notranslate nohighlight">\(w\)</span> that creates list <span class="math notranslate nohighlight">\(L_l\)</span> and <span class="math notranslate nohighlight">\(L_g\)</span> which have size roughly equal to <span class="math notranslate nohighlight">\(\frac{1}{2}\)</span> the size of the original list. But we don’t really have a way of selecting <span class="math notranslate nohighlight">\(w\)</span> that guarantees this to be the case every time. And in fact if we did have such a method of picking <span class="math notranslate nohighlight">\(w\)</span> then we could just use that method to find the median since the value of <span class="math notranslate nohighlight">\(w\)</span> that would divide the list into lists <span class="math notranslate nohighlight">\(L_l\)</span> and <span class="math notranslate nohighlight">\(L_g\)</span> of <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span> size is the median! What if we just pick <span class="math notranslate nohighlight">\(w\)</span> randomly (hence why this is a randomized divide &amp; conquer algorithm)? The worst case scenario here is that we want to run the algorithm for <span class="math notranslate nohighlight">\(k=1\)</span>, so we want the smallest element in the list, and pick a <span class="math notranslate nohighlight">\(w\)</span> that is the largest element in the list each time which would only reduce the size of the list by one at each recursive call. This means we would end up doing <span class="math notranslate nohighlight">\(n\)</span> recursive calls and <span class="math notranslate nohighlight">\(n-i\)</span> comparisons at each call where <span class="math notranslate nohighlight">\(i\)</span> is the recursion level we are on. We would thus do</p>
<div class="math notranslate nohighlight">
\[
\sum^{n}_{i=1}(n-i) 
\]</div>
<p>total comparisons which by induction can be shown to be equal to <span class="math notranslate nohighlight">\(\frac{n(n-1)}{2}\)</span> for <span class="math notranslate nohighlight">\(n \in \mathbb{Z^+}\)</span> so our worst case time complexity is <span class="math notranslate nohighlight">\(O(n^2)\)</span> which is the time a naive approach of just comparing each element with every other one would take to find the median. However the chance that we pick badly like this at every step is incredibly low. For example the chance that we pick the largest element in a list <span class="math notranslate nohighlight">\(n\)</span> elements, assuming each element is equally likely to be chosen, is <span class="math notranslate nohighlight">\(\frac{1}{n}\)</span>. The chance that we do it again once that element is removed is <span class="math notranslate nohighlight">\(\frac{1}{n-1}\)</span> and so on until we get to a list of only one element. That means the probability of this worst case scenario occurring is</p>
<div class="math notranslate nohighlight">
\[
\prod_{i=0}^{n-1}\frac{1}{n-i} = \frac{1}{n!}
\]</div>
<p>which approaches 0 faster than exponentially as <span class="math notranslate nohighlight">\(n\)</span> increases.</p>
<p>But this is just the absolute worse case; it would be more useful to know the time complexity for the case where we pick a pivot that is somewhat good. For example what if we pick a <span class="math notranslate nohighlight">\(w\)</span> which creates lists of size <span class="math notranslate nohighlight">\(\frac{3n}{4}\)</span> that we then recursively run the algorithm on? Well in that case the recurrence is given by</p>
<div class="math notranslate nohighlight">
\[
T(n) = T\left(\frac{3n}{4}\right) + O(n)
\]</div>
<p>and if we use the master theorem we will come to the surprising conclusion that the solution to this recurrence is also <span class="math notranslate nohighlight">\(O(n)\)</span> and in fact is <span class="math notranslate nohighlight">\(O(n)\)</span> for any recurrence relation of the form</p>
<div class="math notranslate nohighlight">
\[
T(n) = T\left(bn\right) + O(n)
\]</div>
<p>where <span class="math notranslate nohighlight">\(b&lt;1\)</span>! So this means we have some leeway in picking <span class="math notranslate nohighlight">\(w\)</span>. If we can find a way to pick a <span class="math notranslate nohighlight">\(w\)</span> that is less than the <span class="math notranslate nohighlight">\(\frac{3n}{4}\)</span>-th largest element and greater than the <span class="math notranslate nohighlight">\(\frac{n}{4}\)</span>-th largest we will have an <span class="math notranslate nohighlight">\(O(n)\)</span> algorithm for finding the median of an unsorted list.</p>
<p>How many elements are there in the list that are less than the <span class="math notranslate nohighlight">\(\frac{3n}{4}\)</span>-th largest element and greater than the <span class="math notranslate nohighlight">\(\frac{n}{4}\)</span>-th largest element (note that it doesn’t matter if the list is sorted)? Well thats <span class="math notranslate nohighlight">\(\frac{3n}{4}-\frac{n}{4}=\frac{n}{2}\)</span> elements. So if we pick a pivot randomly that means we have a <span class="math notranslate nohighlight">\(\frac{1}{2}\)</span> chance of picking a pivot that is one of these elements. This means that on average we have to randomly select an element twice to get a good pivot. This is akin to flipping a fair coin where <span id="id8">[<a class="reference internal" href="../../backmatter/bibliography.html#id29" title="Sanjoy Dasgupta, Christos H Papadimitriou, and Umesh Virkumar Vazirani. Algorithms. McGraw-Hill Higher Education New York, 2008.">Dasgupta <em>et al.</em>, 2008</a>]</span> show that on average we must flip the coin two times before we see a heads. Note that once we randomly select a candiadate for the pivot we must check to see it satisfies the condition of being less than the <span class="math notranslate nohighlight">\(\frac{3n}{4}\)</span>-th largest element and greater than the <span class="math notranslate nohighlight">\(\frac{n}{4}\)</span>-th largest element in the list which will take <span class="math notranslate nohighlight">\(O(n)\)</span> time. So on average we will need to do this twice before we have a good pivot so on average we can expect a time complexity of <span class="math notranslate nohighlight">\(O(n)\)</span> when choosing the pivot in this way and thus our recurrence form earlier will describe the runtime of our algorithm.</p>
</section>
<section id="tighter-bound">
<h3>Tighter bound<a class="headerlink" href="#tighter-bound" title="Link to this heading">#</a></h3>
<p>But this is just the <em>expected/average</em> runtime of the algorithm. Can we modify the algorithm to get an even tighter bound that shows that in the <em>worst</em> case we have a complexity of <span class="math notranslate nohighlight">\(O(n)\)</span>? Well it turns out we can by modifying how we select the pivot which is explained by Dr. Vigoda in lecture and in chapter 9 of <span id="id9">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span>.</p>
<p>So recall that for our recurrence which is of the form</p>
<div class="math notranslate nohighlight">
\[
T(n) = T\left(bn\right) + O(n)
\]</div>
<p>we just need <span class="math notranslate nohighlight">\(b\)</span> to be less than 1 for this recurrence to solve to <span class="math notranslate nohighlight">\(O(n)\)</span>. So lets use this leeway to devise a way to find a good pivot that keeps us within this <span class="math notranslate nohighlight">\(b&lt;1\)</span> range. To this end we will devise an algorithm whose time complexity is described by the following recurrence</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
T(n) &amp;= T\left(\frac{3n}{4}\right) + \left(T\left(\frac{n}{5}\right) + O(n)\right) + O(n) \\
     &amp;= T\left(\frac{3n}{4}\right) + T\left(\frac{n}{5}\right) + O(n) \quad \text{Recall $O(n)+O(n)=O(n)$}\\
     &amp;= T\left(\left(\frac{3}{4}+\frac{1}{5}\right)n\right) +  O(n)
\end{align*}
\end{split}\]</div>
<p>The extra terms <span class="math notranslate nohighlight">\(\left(T\left(\frac{n}{5}\right) + O(n)\right)\)</span> will account for the time taken to find a good pivot at each recursion level. And note that this still solves to <span class="math notranslate nohighlight">\(O(n)\)</span> since <span class="math notranslate nohighlight">\(\left(\frac{3}{4}+\frac{1}{5}\right)&lt;1\)</span>. But where does this extra term come from? Well the strategy we will use to find the pivot is we will create a list <span class="math notranslate nohighlight">\(S\)</span> of size <span class="math notranslate nohighlight">\(\frac{n}{5}\)</span> and recursively call our <span class="math notranslate nohighlight">\(\text{selection}\)</span> algorithm <em>on it</em> to find it’s median which we will then us as out pivot.</p>
<section id="median-of-medians">
<h4>Median of medians<a class="headerlink" href="#median-of-medians" title="Link to this heading">#</a></h4>
<p>The key insight is that we want the elements of <span class="math notranslate nohighlight">\(S\)</span> to possess a certain property. That is we want each <span class="math notranslate nohighlight">\(x\in S\)</span> to have the property that there are a few elements of <span class="math notranslate nohighlight">\(L\)</span> which are less than or equal to it and a few elements of <span class="math notranslate nohighlight">\(L\)</span> which are greater than or equal to it. In our case we will pick “a few” to mean <span class="math notranslate nohighlight">\(2\)</span>. But how will we ensure this?</p>
<p>So first we will take <span class="math notranslate nohighlight">\(L\)</span> and divide it into <span class="math notranslate nohighlight">\(\frac{n}{5}\)</span> smaller lists <span class="math notranslate nohighlight">\(G_1,G_2,...,G_{n/5}\)</span> which each have <span class="math notranslate nohighlight">\(5\)</span> elements in them. We will then <em>sort</em> each list. You might think that this ruins our time complexity of <span class="math notranslate nohighlight">\(O(n)\)</span> since (comparison-based) sorting takes <span class="math notranslate nohighlight">\(O(n\log{n})\)</span> time but you would be incorrect. This is because each list has a constant number of elements in it regardless of the input size <span class="math notranslate nohighlight">\(n\)</span> i.e. <span class="math notranslate nohighlight">\(5\)</span> elements. So it in fact takes <span class="math notranslate nohighlight">\(O(1)\)</span> time to sort each list! Once each <span class="math notranslate nohighlight">\(G_i\)</span> is sorted we find its median, <span class="math notranslate nohighlight">\(m_i\)</span>, which takes <span class="math notranslate nohighlight">\(O(1)\)</span> time since the list is sorted (just look at the middle element) and create <span class="math notranslate nohighlight">\(S=[m_1,m_2,...m_{n/5}]\)</span> from these medians. We will then select our pivot from this list by finding it’s median by <em>recursively calling <span class="math notranslate nohighlight">\(\text{selection}\)</span> on it</em> with <span class="math notranslate nohighlight">\(k=\frac{n}{10}\)</span>. <span class="math notranslate nohighlight">\(k=\frac{n}{10}\)</span> since <span class="math notranslate nohighlight">\(S\)</span> is of size <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span> the median is the <span class="math notranslate nohighlight">\(\frac{\frac{n}{5}}{2} = \frac{n}{10}\)</span> smallest element. This whole process is described by the recurrence</p>
<div class="math notranslate nohighlight">
\[
T(n) = T\left(\frac{n}{5}\right) +  O(n)
\]</div>
<p>which were the extra terms we added to the recurrence of the expected time <span class="math notranslate nohighlight">\(\text{selection}\)</span> algorithm above. The new algorithm is given below and as we can see by solving this recurrence has a worst case time complexity that is linear. This is a pretty impressive algorithm and complexity and it took quite a bit of work to find it. Unfortunately as <span id="id10">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span> say it is not as practical as the earlier randomized version of this algorithm but is still of great theoretical interest.</p>
<div class="proof algorithm dropdown admonition" id="selection $O(n)$ Worst Case Time">
<p class="admonition-title"><span class="caption-number">Algorithm 19.9 </span> (Selection - <span class="math notranslate nohighlight">\(O(n)\)</span> Worst Case Time)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>procedure</strong> <span class="math notranslate nohighlight">\(\text{selection}(L, k)\)</span>:</p>
<p><strong>Inputs</strong> Given a list <span class="math notranslate nohighlight">\(L[1,...,n]\)</span> of length <span class="math notranslate nohighlight">\(n\)</span> and an integer <span class="math notranslate nohighlight">\(1\leq k \leq n\)</span></p>
<p><strong>Output</strong> The <span class="math notranslate nohighlight">\(k\)</span>-th smallest element in the list</p>
<ol class="arabic simple">
<li><p>Break <span class="math notranslate nohighlight">\(L\)</span> into <span class="math notranslate nohighlight">\(\frac{n}{5}\)</span> groups, <span class="math notranslate nohighlight">\(G_1,G_2,...,G_{n/5}\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Lines 1-4 are for selecting the pivot <span class="math notranslate nohighlight">\(w\)</span></p></li>
<li><p>For <span class="math notranslate nohighlight">\(i=1\)</span> to <span class="math notranslate nohighlight">\(\frac{n}{5}\)</span>:</p>
<ol class="arabic simple">
<li><p>Sort <span class="math notranslate nohighlight">\(G_i\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Sort each <span class="math notranslate nohighlight">\(G_i\)</span></p></li>
<li><p>Set <span class="math notranslate nohighlight">\(m_i=\text{median}(G_i)\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Set <span class="math notranslate nohighlight">\(m_i\)</span> to median of sorted list <span class="math notranslate nohighlight">\(G_i\)</span></p></li>
</ol>
</li>
<li><p><span class="math notranslate nohighlight">\(S=[m_1,m_2,...,m_{n/5}]\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Create new list of median values</p></li>
<li><p><span class="math notranslate nohighlight">\(w = \text{selection}(S, \frac{n}{10})\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Recursively call algorithm to select a good pivot from this sample</p></li>
<li><p>Divide <span class="math notranslate nohighlight">\(L\)</span> into the lists <span class="math notranslate nohighlight">\(L_l\)</span>, <span class="math notranslate nohighlight">\(L_w\)</span> and <span class="math notranslate nohighlight">\(L_g\)</span></p></li>
<li><p>if <span class="math notranslate nohighlight">\(k \leq |L_l|\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(\text{selection}(L_l, k)\)</span></p></li>
</ol>
</li>
<li><p>if <span class="math notranslate nohighlight">\(k &gt; |L_l| + |L_w|\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(\text{selection}(L_g, k-|L_l| - |L_w|)\)</span></p></li>
</ol>
</li>
<li><p>else:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(w\)</span></p></li>
</ol>
</li>
</ol>
</section>
</div></section>
<section id="proof-of-good-pivot-selection">
<h4>Proof of good pivot selection<a class="headerlink" href="#proof-of-good-pivot-selection" title="Link to this heading">#</a></h4>
<p>But why does the median of this list of medians, <span class="math notranslate nohighlight">\(S\)</span>, yield a good pivot? First note that since each group <span class="math notranslate nohighlight">\(G_i\)</span> is of size <span class="math notranslate nohighlight">\(5\)</span> if we sort it and take its median then we know exactly <span class="math notranslate nohighlight">\(2\)</span> elements will be greater than or equal to <span class="math notranslate nohighlight">\(m_i\)</span> and exactly <span class="math notranslate nohighlight">\(2\)</span> elements will be less than or equal to <span class="math notranslate nohighlight">\(m_i\)</span> so this means each element of <span class="math notranslate nohighlight">\(S\)</span> will possess the property we said we wanted earlier.</p>
</section>
</section>
</section>
<section id="quicksort">
<h2>Quicksort<a class="headerlink" href="#quicksort" title="Link to this heading">#</a></h2>
<p>Some of the ideas behind the median algorithm we just covered can also be applied to create an asymptotically efficient and empirically performant divide and conquer sorting algorithm called Quicksort. This algorithm, along with the one we will cover in the next section, was named as one of the top 10 with the greatest influence on the development and practice of science and engineering in the 20th century by <a class="reference external" href="https://www.computer.org/csdl/magazine/cs/2000/01/c1022/13rRUxBJhBm">IEEE</a>.</p>
</section>
<section id="fast-fourier-transform">
<h2>Fast Fourier transform<a class="headerlink" href="#fast-fourier-transform" title="Link to this heading">#</a></h2>
<p>This algorithm is covered by both <span id="id11">[<a class="reference internal" href="../../backmatter/bibliography.html#id29" title="Sanjoy Dasgupta, Christos H Papadimitriou, and Umesh Virkumar Vazirani. Algorithms. McGraw-Hill Higher Education New York, 2008.">Dasgupta <em>et al.</em>, 2008</a>]</span> and <span id="id12">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span>.</p>
<section id="background">
<h3>Background<a class="headerlink" href="#background" title="Link to this heading">#</a></h3>
<p>The fast (discrete) Fourier transform (FFT) is an algorithm that has revolutionized signal processing <span id="id13">[<a class="reference internal" href="../../backmatter/bibliography.html#id29" title="Sanjoy Dasgupta, Christos H Papadimitriou, and Umesh Virkumar Vazirani. Algorithms. McGraw-Hill Higher Education New York, 2008.">Dasgupta <em>et al.</em>, 2008</a>]</span>.</p>
<p>The continuous time Fourier transform, Fourier transform for short, of a function <span class="math notranslate nohighlight">\(x(t)\)</span>, denoted as <span class="math notranslate nohighlight">\(\hat{x}(f)\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[
\hat{x}(f) = \int_{-\infty}^{\infty}x(t)e^{-i2\pi f t}dt
\]</div>
<p>and the discrete time Fourier transform of a function <span class="math notranslate nohighlight">\(x(t)\)</span>, denoted as <span class="math notranslate nohighlight">\(\hat{x}(f)\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[
\hat{x}(f) = \sum_{n=-\infty}^{\infty}x[n]e^{-i2\pi f t}.
\]</div>
<p>The <em>discrete</em> Fourier transform transforms a discrete sequence of complex numbers <span class="math notranslate nohighlight">\(\{x_0,x_1,...,x_{N-1}\}\)</span> into another discrete sequence of complex numbers
<span class="math notranslate nohighlight">\(\{X_0, X_1,...,X_{N-1}\}\)</span> such that</p>
<div class="math notranslate nohighlight">
\[
X_k = \sum_{n=0}^{N-1}x_n e^{-i2\pi k n /N}.
\]</div>
<p>For the FFT we are interested in</p>
<p>We first looked at how to multiply integers efficiently using a divide and conquer approach followed by how to multiply matrices. For the FFT we will extend this to the multiplication of <em>polynomials</em>.</p>
</section>
<section id="representations-of-polynomials">
<h3>Representations of polynomials<a class="headerlink" href="#representations-of-polynomials" title="Link to this heading">#</a></h3>
<p>First let’s go over two different ways we can represent polynomials.</p>
<section id="coefficient-representation">
<h4>Coefficient representation<a class="headerlink" href="#coefficient-representation" title="Link to this heading">#</a></h4>
<p>Recall that a general polynomial <span class="math notranslate nohighlight">\(A(x)\)</span> of degree <span class="math notranslate nohighlight">\(n-1\)</span> can be written as</p>
<div class="math notranslate nohighlight">
\[
A(x) = a_0 + a_1x + a_2x^2 + \cdots + a_{n-1}x^{n-1}
\]</div>
<p>where <span class="math notranslate nohighlight">\(a_i \in \{a_0,...,a_{n-1}\}\)</span> are coefficients.</p>
<p>Given another polynomial <span class="math notranslate nohighlight">\(B(x) = b_0 + b_1x + b_2x^2 + \cdots + b_{n-1}x^{n-1}\)</span> we want an algorithm that can compute their product</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
C(x) &amp;= A(x)B(x) \\
&amp;= c_0 + c_1x + c_2x^2 + \cdots + c_{2n-2}x^{2n-2}
\end{align*}
\end{split}\]</div>
<p>Note that the resulting function will be a polynomial of degree at most <span class="math notranslate nohighlight">\(2n-2\)</span> and the coefficients have the form</p>
<div class="math notranslate nohighlight">
\[
c_i = a_0b_i + a_1b_{i-1} + \cdots + a_ib_0 = \sum_{k=0}^ia_kb_{i-k}
\]</div>
<p>Note that if <span class="math notranslate nohighlight">\(i&gt;n-1\)</span> then <span class="math notranslate nohighlight">\(b_i=0\)</span> and <span class="math notranslate nohighlight">\(a_i=0\)</span> since <span class="math notranslate nohighlight">\(A(x)\)</span> and <span class="math notranslate nohighlight">\(B(x)\)</span> only have coefficients up to <span class="math notranslate nohighlight">\(a_{n-1}\)</span> and <span class="math notranslate nohighlight">\(b_{n-1}\)</span> respectively. This operation is actually known as a convolution and is denoted as <span class="math notranslate nohighlight">\(a\ast b\)</span>. Computing <span class="math notranslate nohighlight">\(c_i\)</span> takes <span class="math notranslate nohighlight">\(O(i)\)</span> time, where <span class="math notranslate nohighlight">\(i\leq 2n-2\)</span>, and there are at most <span class="math notranslate nohighlight">\(2n-1\)</span> coefficients <span class="math notranslate nohighlight">\(c_i\)</span> so this formula leads to an <span class="math notranslate nohighlight">\(O((2n-2)(2n-1))=O(n^2)\)</span> time algorithm for multiplying polynomials.</p>
<p>We can notice something interesting here: each of these polynomials is uniquely determined by its coefficients <span class="math notranslate nohighlight">\((a_0,a_1,...,a_{n-1})\)</span> and <span class="math notranslate nohighlight">\((b_0,b_1,...,b_{n-1})\)</span> and the resulting product can be computed using only these coefficients. Thus we can represent a polynomial as a vector of coefficients and their product as the convolution between these vectors of coefficients.</p>
</section>
<section id="value-representation">
<h4>Value representation<a class="headerlink" href="#value-representation" title="Link to this heading">#</a></h4>
<div class="proof theorem dropdown admonition" id="value-rep">
<p class="admonition-title"><span class="caption-number">Theorem 19.3 </span> (Value representation of polynomials)</p>
<section class="theorem-content" id="proof-content">
<p>For a degree <span class="math notranslate nohighlight">\(n-1\)</span> polynomial <span class="math notranslate nohighlight">\(A(x)\)</span> the set of values <span class="math notranslate nohighlight">\((A(x_1),...,A(x_n))\)</span> where <span class="math notranslate nohighlight">\(x_1\not = x_2 \not= \cdots \not = x_i \)</span> uniquely characterizes the polynomial <span class="math notranslate nohighlight">\(A(x)\)</span>.</p>
</section>
</div><p>In addition to this there is another way to represent a polynomial and that is as <span class="math notranslate nohighlight">\(A(x) := (A(x_1),...,A(x_n))\)</span>. That is as a vector of values the polynomial takes on at the points <span class="math notranslate nohighlight">\(x_1,x_2,...x_{n}\)</span> where all <span class="math notranslate nohighlight">\(x_i\)</span> are <em>distinct</em>. These <span class="math notranslate nohighlight">\(n\)</span> points also uniquely determine a polynomial of degree <span class="math notranslate nohighlight">\(n-1\)</span>. This representation is more useful for multiplying polynomials and what the FFT does is switch between these representations to multiply polynomials more efficiently than our <span class="math notranslate nohighlight">\(O(n^2)\)</span> time method using the coefficient representation.</p>
<p>But why is it more efficient to use this representation? Well if we have two value vectors <span class="math notranslate nohighlight">\(A(x) := (A(x_1),...,A(x_{2n}))\)</span> and <span class="math notranslate nohighlight">\(B(x) := (B(x_1),...,B(x_{2n}))\)</span> for two polynomials their product polynomial is uniquely characterized by the vector that results from taking the pairwise product of elements of the two vectors so <span class="math notranslate nohighlight">\(C(x) := (A(x_1)B(x_1),...,A(x_{2n})B(x_{2n}))\)</span>. Each of these products takes <span class="math notranslate nohighlight">\(O(1)\)</span> time to compute since we are just multiplying two scalars and there are <span class="math notranslate nohighlight">\(2n\)</span> of these products to compute so the time complexity is <span class="math notranslate nohighlight">\(O(n)\)</span>! Why are there <span class="math notranslate nohighlight">\(2n\)</span> elements in these vectors instead of <span class="math notranslate nohighlight">\(n\)</span>? Well recall that the product of two <span class="math notranslate nohighlight">\(n\)</span> degree polynomials has degree of at most <span class="math notranslate nohighlight">\(2n\)</span> so we need to have at least <span class="math notranslate nohighlight">\(2n\)</span> points in our vectors for <span class="math notranslate nohighlight">\(A(x)\)</span> and <span class="math notranslate nohighlight">\(B(x)\)</span> to uniquely characterize their resulting product polynomial.</p>
</section>
<section id="naive-transformation">
<h4>Naive transformation<a class="headerlink" href="#naive-transformation" title="Link to this heading">#</a></h4>
<p>Given the coefficient representation of a polynomial and <span class="math notranslate nohighlight">\(2n\)</span> points <span class="math notranslate nohighlight">\(X=\{x_1,...,x_{2n}\}\)</span> we want to evaluate the polynomial at the naive approach to switch to the value representation would involve evaluating the polynomial at each of these points by computing</p>
<div class="math notranslate nohighlight">
\[
A(x_i) = a_0 + a_1x_i + \cdots + a_{n-1}x_i^{n-1}
\]</div>
<p>for each <span class="math notranslate nohighlight">\(x_i\)</span>. This is naive since computing <span class="math notranslate nohighlight">\(A(x_i)\)</span> takes <span class="math notranslate nohighlight">\(O(n)\)</span> scalar multiplication and computing all <span class="math notranslate nohighlight">\(2n\)</span> values of <span class="math notranslate nohighlight">\(A(x_i)\)</span> thus yields a time complexity of <span class="math notranslate nohighlight">\(O(n^2)\)</span> so we might as well have just used the coefficients to find the product of the polynomial instead of going through the trouble of converting to the value representation.</p>
<p>The FFT, by picking a clever set of points <span class="math notranslate nohighlight">\(X=\{x_1,...,x_{2n}\}\)</span>, will allow us to switch from the coefficient representation to the value representation in <span class="math notranslate nohighlight">\(O(n\log{n})\)</span> time, after which we can use the efficient <span class="math notranslate nohighlight">\(O(n)\)</span> time multiplication method available in the value representation and then switch back (this part is called <em>interpolation</em>) to the coefficient representation in <span class="math notranslate nohighlight">\(O(n\log{n})\)</span> time for an overall time complexity of <span class="math notranslate nohighlight">\(O(n\log{n})\)</span>.</p>
</section>
</section>
<section id="choosing-the-set-x">
<h3>Choosing the set <span class="math notranslate nohighlight">\(X\)</span><a class="headerlink" href="#choosing-the-set-x" title="Link to this heading">#</a></h3>
<p>So to quickly summarize our task thus far: Given a set of coefficients <span class="math notranslate nohighlight">\((a_0,a_1,...,a_{n-1})\)</span> for the polynomial <span class="math notranslate nohighlight">\(A(x)\)</span> how quickly can we compute the set of values <span class="math notranslate nohighlight">\((A(x_0),...,A(x_{2n}))\)</span> for some set, <span class="math notranslate nohighlight">\(X = \{x_1,x_2,...,x_{2n}\}\)</span>, in the domain of the function. We saw the naive method results in a time complexity of <span class="math notranslate nohighlight">\(O(n^2)\)</span> which is not good but postulated that there maybe a more clever way to do this give a proper choice of <span class="math notranslate nohighlight">\(X\)</span>.</p>
<p>Suppose were to choose a set of <span class="math notranslate nohighlight">\(2n\)</span> points that possess the following property: the first <span class="math notranslate nohighlight">\(n\)</span> points have the same magnitude but opposite sign of the last <span class="math notranslate nohighlight">\(n\)</span> points. This would mean for example that <span class="math notranslate nohighlight">\(-x_1 = x_{n+1}\)</span>, <span class="math notranslate nohighlight">\(-x_2 = x_{n+2}\)</span>, <span class="math notranslate nohighlight">\(-x_3 = x_{n+3}\)</span> and in general <span class="math notranslate nohighlight">\(-x_{i}=x_{n+i}\)</span>. Why might this be useful? Well if this property holds then that would mean that <span class="math notranslate nohighlight">\(A(x_{n+i})=A(-x_{i})\)</span>. Now let’s think about the odd power terms and the even power terms of <span class="math notranslate nohighlight">\(A(x)\)</span>. For the even power terms like <span class="math notranslate nohighlight">\(a_2x^{2}\)</span> we have <span class="math notranslate nohighlight">\(a_2x^{2}=a_2(-x)^{2}\)</span> and in general</p>
<div class="math notranslate nohighlight">
\[
a_{2k}x^{2k}=a_{2k}(-x)^{2k}
\]</div>
<p>This means that we need not compute the value of the even power terms for both <span class="math notranslate nohighlight">\(x_i\)</span> and <span class="math notranslate nohighlight">\(x_{n+i}\)</span> since they would be the same!</p>
<p>Now what about the odd power terms? Well in general we have</p>
<div class="math notranslate nohighlight">
\[
-a_{2k+1}x^{2k+1}=a_{2k+1}(-x)^{2k+1}
\]</div>
<p>meaning the odd power terms have opposite sign for <span class="math notranslate nohighlight">\(x_i\)</span> and <span class="math notranslate nohighlight">\(x_{n+i}\)</span>. So we also need not compute the value of the even power terms for both <span class="math notranslate nohighlight">\(x_i\)</span> and <span class="math notranslate nohighlight">\(x_{n+i}\)</span> since they would only differ by a sign! So with this in mind let’s group the coefficients of the even power terms into one vector of coefficients</p>
<div class="math notranslate nohighlight">
\[
a_E = (a_0,a_2,a_4,...,a_{n-2})
\]</div>
<p>and the odd power coefficients into another vector</p>
<div class="math notranslate nohighlight">
\[
a_O = (a_1,a_3,a_5,...,a_{n-1}).
\]</div>
<p>We can then define two new polynomials, <span class="math notranslate nohighlight">\(A_E(y)\)</span> and <span class="math notranslate nohighlight">\(A_o(y)\)</span>, based on these two new vectors</p>
<div class="math notranslate nohighlight">
\[\begin{split}
A_E(y) = a_0 + a_2y + a_4y^2 + \cdots + a_{n-2}y^{\frac{n-2}{2}} \\
A_O(y) = a_1 + a_3y + a_5y^2 + \cdots + a_{n-1}y^{\frac{n-2}{2}}
\end{split}\]</div>
<p>we use <span class="math notranslate nohighlight">\(y\)</span> to not create confusion for the explanation that follows later. Notice that we have <em>divided</em> this polynomial into two polynomials of degree <span class="math notranslate nohighlight">\(\frac{n-2}{2}=\frac{n}{2}-1\)</span>. So we have divided the problem into 2 subproblems of <span class="math notranslate nohighlight">\(\frac{1}{2}\)</span> the size.</p>
<p>Now how do these polynomials relate to the original polynomial <span class="math notranslate nohighlight">\(A(x)\)</span>? Well if we evaluate <span class="math notranslate nohighlight">\(A_E(y)\)</span> with <span class="math notranslate nohighlight">\(y=x^2\)</span> we will get the even power terms of <span class="math notranslate nohighlight">\(A(x)\)</span>. We can see this if we notice that in <span class="math notranslate nohighlight">\(A_E(y)\)</span> the coefficients are associated with polynomials of half their original degree from <span class="math notranslate nohighlight">\(A(x)\)</span>.</p>
<p>Now how do we recover the odd power terms of <span class="math notranslate nohighlight">\(A(x)\)</span>? By evaluating <span class="math notranslate nohighlight">\(xA_O(x^2)\)</span>. Now that we have a way of recovering both the even and odd power terms of <span class="math notranslate nohighlight">\(A(x)\)</span> we can write it in terms of <span class="math notranslate nohighlight">\(A_E(y)\)</span> and <span class="math notranslate nohighlight">\(A_o(y)\)</span> as follows</p>
<div class="math notranslate nohighlight">
\[
A(x) = A_E(x^2) + xA_O(x^2)
\]</div>
<section id="complex-numbers">
<h4>Complex numbers<a class="headerlink" href="#complex-numbers" title="Link to this heading">#</a></h4>
<p>Here I will list some facts about complex numbers that will be useful to know. A complex number is written as <span class="math notranslate nohighlight">\(z=a+ib\)</span>. And can be alternativly represented, using Euler’s formula, as</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
z&amp;=a+ib \\
&amp;=re^{i\theta} \\
&amp;=r(\cos{(\theta)} + i\sin{(\theta)})
\end{align*}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(r = |z|\)</span> and <span class="math notranslate nohighlight">\(\theta=\tan^{-1}{\left(\frac{b}{a}\right)}\)</span> is the angle made by the vector <span class="math notranslate nohighlight">\(a+ib\)</span> in the complex plane with the positive real number line.</p>
</section>
<section id="roots-of-unity">
<h4>Roots of unity<a class="headerlink" href="#roots-of-unity" title="Link to this heading">#</a></h4>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th root of unity is the complex number <span class="math notranslate nohighlight">\(z\)</span> that satisfies</p>
<div class="math notranslate nohighlight">
\[
z^n = 1
\]</div>
<p>For example for <span class="math notranslate nohighlight">\(n=2\)</span> the (square) roots of unity are <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(-1\)</span> and for <span class="math notranslate nohighlight">\(n=4\)</span> the (fourth) roots of unity are <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\(-1\)</span>, <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(-i\)</span>. Another way of saying this is what are the <span class="math notranslate nohighlight">\(n\)</span>-th roots of <span class="math notranslate nohighlight">\(1\)</span> since unity is just a fancy word for <span class="math notranslate nohighlight">\(1\)</span> here. As Dr. Vigoda explains in lecture the <span class="math notranslate nohighlight">\(n\)</span>-th roots of unit lie on the circumference of the unit circle centered at the origin of the complex plane. And in general the <span class="math notranslate nohighlight">\(n\)</span>-th roots of unity are given by</p>
<div class="math notranslate nohighlight">
\[
\omega_n^k=\exp{\left(\frac{2k\pi i}{n}\right)} \quad \text{where} \quad k\in \{0,1,...,n-1\}.
\]</div>
<p>The roots of unity have two properties that make them useful for the FFT algorithm.</p>
<p>Firstly for even values of <span class="math notranslate nohighlight">\(n\)</span> they possess the property we want numbers in our set <span class="math notranslate nohighlight">\(X\)</span> to have. That is to say the first <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span> <span class="math notranslate nohighlight">\(n\)</span>-th roots of unity are equal in magnitude but opposite in sign to the last <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span> <span class="math notranslate nohighlight">\(n\)</span>-th roots of unity e.g. <span class="math notranslate nohighlight">\(\omega_n^0=-\omega_n^{\frac{n}{2}}\)</span>. And in general we have</p>
<div class="math notranslate nohighlight">
\[
\omega_n^{k} = -\omega_n^{\frac{n}{2}+k}.
\]</div>
<p>Secondly when <span class="math notranslate nohighlight">\(n\)</span> is a power of <span class="math notranslate nohighlight">\(2\)</span> the <span class="math notranslate nohighlight">\(n\)</span>-th roots of unity <em>squared</em> are equal to the <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span>-nd roots of unity so</p>
<div class="math notranslate nohighlight">
\[
(\omega^k_n)^2 = \omega^k_{\frac{n}{2}}.
\]</div>
<p>Note that if you intend to multiply two polynomials, <span class="math notranslate nohighlight">\(A(x)\)</span> and <span class="math notranslate nohighlight">\(B(x)\)</span>, of degree at most <span class="math notranslate nohighlight">\(n-1\)</span> you must use the <span class="math notranslate nohighlight">\(2n\)</span>-th roots of unity since the resulting polynomials <span class="math notranslate nohighlight">\(C(x)\)</span> will be of degree at most <span class="math notranslate nohighlight">\(2n-1\)</span>.</p>
<div class="proof algorithm dropdown admonition" id="FFT">
<p class="admonition-title"><span class="caption-number">Algorithm 19.10 </span> (Fast (Discrete) Fourier Transform)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>procedure</strong> <span class="math notranslate nohighlight">\(\text{FFT}(a,\omega)\)</span>:</p>
<p><strong>Inputs</strong> Given the coefficient representation <span class="math notranslate nohighlight">\(a=(a_0,a_1,...,a_{n-1})\)</span> of a <span class="math notranslate nohighlight">\(n-1\)</span> degree polynomial <span class="math notranslate nohighlight">\(A(x)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is power of <span class="math notranslate nohighlight">\(2\)</span>
and <span class="math notranslate nohighlight">\(\omega\)</span> is a primitive <span class="math notranslate nohighlight">\(n\)</span>-th root of unity.</p>
<p><strong>Output</strong> The polynomial evaluated at the <span class="math notranslate nohighlight">\(n\)</span>-th roots of unity i.e. it’s value representation <span class="math notranslate nohighlight">\((A(w_n^0),A(w_n^1),...,A(w_n^{n-1}))\)</span> denoted <span class="math notranslate nohighlight">\(M_n(\omega)a\)</span></p>
<ol class="arabic simple">
<li><p>if <span class="math notranslate nohighlight">\(\omega=1\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(a\)</span></p></li>
</ol>
</li>
<li><p><span class="math notranslate nohighlight">\((s_0,s_1,...,s_{\frac{n}{2}-1})= \text{FFT}((a_0,a_2,...,a_{n-2}), \omega^2)\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Recursively evaluate <span class="math notranslate nohighlight">\(A_E(y)\)</span> on the <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span>-nd roots of unity</p></li>
<li><p><span class="math notranslate nohighlight">\((s_0',s_1',...,s_{\frac{n}{2}-1}')= \text{FFT}((a_1,a_3,...,a_{n-1}), \omega^2)\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Recursively evaluate <span class="math notranslate nohighlight">\(A_O(y)\)</span> on the <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span>-nd roots of unity</p></li>
<li><p>for <span class="math notranslate nohighlight">\(j=0\)</span> to <span class="math notranslate nohighlight">\(\frac{n}{2}-1\)</span>: <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Combine evaluated <span class="math notranslate nohighlight">\(A_O(y)\)</span> and <span class="math notranslate nohighlight">\(A_E(y)\)</span> to create value rep. of <span class="math notranslate nohighlight">\(A(x)\)</span></p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(r_j=s_j+\omega^js_j'\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(r_{j+\frac{n}{2}}=s_j-\omega^js_j'\)</span></p></li>
</ol>
</li>
<li><p>return <span class="math notranslate nohighlight">\((r_0,r_1,...,r_{n-1})\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> <span class="math notranslate nohighlight">\((r_0,r_1,...,r_{n-1})=(A(w_n^0),A(w_n^1),...,A(w_n^{n-1}))\)</span></p></li>
</ol>
</section>
</div><p>To perform the inverse FFT of <span class="math notranslate nohighlight">\(v=\text{FFT}(a, \omega)\)</span> we simply compute</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{n}\text{FFT}( v, \omega^{-1}  )
\]</div>
<p>which is a remarkable fact. We only need to run the same algorithm again but on the <em>value representation</em>  of the polynomial we got from the first FFT computation with the <em>inverse</em> of the roots of unity we used. This gives us the coefficients of the polynomial that is characterized by the values in the list <span class="math notranslate nohighlight">\(v\)</span>. The extra <span class="math notranslate nohighlight">\(\frac{1}{n}\)</span> comes from</p>
</section>
</section>
</section>
<section id="practice-problems">
<h2>Practice problems<a class="headerlink" href="#practice-problems" title="Link to this heading">#</a></h2>
<section id="id14">
<h3>2.2<a class="headerlink" href="#id14" title="Link to this heading">#</a></h3>
</section>
<section id="id15">
<h3>2.4<a class="headerlink" href="#id15" title="Link to this heading">#</a></h3>
</section>
<section id="id16">
<h3>2.5<a class="headerlink" href="#id16" title="Link to this heading">#</a></h3>
</section>
<section id="id17">
<h3>2.6<a class="headerlink" href="#id17" title="Link to this heading">#</a></h3>
</section>
<section id="sum-of-n-th-roots-of-unity">
<h3>2.7 Sum of <span class="math notranslate nohighlight">\(n\)</span>-th roots of unity<a class="headerlink" href="#sum-of-n-th-roots-of-unity" title="Link to this heading">#</a></h3>
<!-- $$
\sum_{k=0}^{n-1}\exp{\left(\frac{2k\pi i}{n}\right)} = \sum_{k=0}^{n-1}\left[\cos{\left(\frac{2k\pi}{n}\right)} + i\sin{\left(\frac{2k\pi}{n}\right)}\right]
$$ -->
<p>Recall that the <span class="math notranslate nohighlight">\(n\)</span>-th roots of unity have the property that the first <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span> <span class="math notranslate nohighlight">\(n\)</span>-th roots are equal in magnitude but opposite in sign to the last <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span> <span class="math notranslate nohighlight">\(n\)</span>-th roots so the sum of the <span class="math notranslate nohighlight">\(n\)</span>-th roots of unity is <span class="math notranslate nohighlight">\(0\)</span> if <span class="math notranslate nohighlight">\(n\)</span> is even. If <span class="math notranslate nohighlight">\(n\)</span> is odd then the sum equal to <span class="math notranslate nohighlight">\(w_n^{n-1}\)</span> as the first <span class="math notranslate nohighlight">\(n-1\)</span> roots still posses the property that the first <span class="math notranslate nohighlight">\(\frac{n-1}{2}\)</span> are equal in magnitude and opposite in sign to the <span class="math notranslate nohighlight">\(\frac{n-1}{2}\)</span>.</p>
</section>
<section id="id18">
<h3>2.12<a class="headerlink" href="#id18" title="Link to this heading">#</a></h3>
</section>
<section id="removing-duplicates">
<h3>2.14 Removing duplicates<a class="headerlink" href="#removing-duplicates" title="Link to this heading">#</a></h3>
<p>Run merge sort on the array and during the merge step check for duplicates and if a duplicate is detected simply throw away one of the duplicates and proceed with the merge step. This method takes <span class="math notranslate nohighlight">\(O(n\log{n})\)</span> time since we don’t add any modifications that take more than <span class="math notranslate nohighlight">\(O(1)\)</span> time to perform during the merge step.</p>
</section>
<section id="in-place-split">
<h3>2.15 In-place split<a class="headerlink" href="#in-place-split" title="Link to this heading">#</a></h3>
</section>
<section id="a-i-i">
<h3>2.17 <span class="math notranslate nohighlight">\(A[i]=i\)</span><a class="headerlink" href="#a-i-i" title="Link to this heading">#</a></h3>
</section>
<section id="id19">
<h3>2.18<a class="headerlink" href="#id19" title="Link to this heading">#</a></h3>
</section>
<section id="id20">
<h3>2.19<a class="headerlink" href="#id20" title="Link to this heading">#</a></h3>
</section>
<section id="id21">
<h3>2.20<a class="headerlink" href="#id21" title="Link to this heading">#</a></h3>
</section>
<section id="selection-with-two-sorted-lists">
<h3>2.22 Selection with two sorted lists<a class="headerlink" href="#selection-with-two-sorted-lists" title="Link to this heading">#</a></h3>
<p>We have two lists <span class="math notranslate nohighlight">\(A=a_1,...,a_n\)</span> and <span class="math notranslate nohighlight">\(B=b_1,...,b_m\)</span> that are sorted in non-descending order and we want to find the <span class="math notranslate nohighlight">\(k\)</span>-th smallest element in the union (combination) of these two lists. The straightforward method is to simply concatenate the lists and use either FastSelect which is <span class="math notranslate nohighlight">\(\Theta(n+m)\)</span> time or QuickSelect which is <span class="math notranslate nohighlight">\(O(n+m)\)</span> expected time. But the problem wants us to do this in <span class="math notranslate nohighlight">\(O(\log(n)+\log(m))\)</span> time. This makes me think we need to use concepts from merge sorts merge step, since the arrays are sorted, and the concepts from the selection algorithm since we want to find the <span class="math notranslate nohighlight">\(k\)</span>-th smallest number.</p>
<p>We’ll have to utilize the fact that the two lists are sorted to solve this problem. Let’s start by asking where the <em>smallest</em> element in the union would be. Well it’s going to either be <span class="math notranslate nohighlight">\(a_1\)</span> or <span class="math notranslate nohighlight">\(b_1\)</span> since those are the smallest elements from the two respective lists.</p>
<p>Now let <span class="math notranslate nohighlight">\(M_m\)</span> and <span class="math notranslate nohighlight">\(M_n\)</span> be the index of the middle of list <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> respectively. If <span class="math notranslate nohighlight">\(M_m + M_n \geq k\)</span> what does that tell us? By extending our thought experiment from above we can conclude that the <span class="math notranslate nohighlight">\(k\)</span>-th smallest element must be</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">load_ext</span> watermark
<span class="o">%</span><span class="k">watermark</span> -n -u -v -iv
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Last updated: Sun Jul 14 2024

Python implementation: CPython
Python version       : 3.10.12
IPython version      : 8.22.2
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./computerscience/algorithms"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="numerical_algos.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Number-theoretic algorithms</p>
      </div>
    </a>
    <a class="right-next"
       href="dynamic_prog.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Dynamic programming</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#binary-search">Binary search</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#integer-multiplication">Integer multiplication</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-recurrence-relations">Solving recurrence relations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#substitution">Substitution</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recursion-tree">Recursion-tree</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#master-method">Master method</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#square-matrix-multiplication">Square matrix multiplication</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#naive-matrix-multiplication">Naive matrix multiplication</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#strassens-algorithm">Strassen’s algorithm</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#merge-sort">Merge sort</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#medians">Medians</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#randomized-divide-conquer">Randomized divide &amp; conquer</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tighter-bound">Tighter bound</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#median-of-medians">Median of medians</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#proof-of-good-pivot-selection">Proof of good pivot selection</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#quicksort">Quicksort</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#fast-fourier-transform">Fast Fourier transform</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#background">Background</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#representations-of-polynomials">Representations of polynomials</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#coefficient-representation">Coefficient representation</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#value-representation">Value representation</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#naive-transformation">Naive transformation</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-the-set-x">Choosing the set <span class="math notranslate nohighlight">\(X\)</span></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#complex-numbers">Complex numbers</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#roots-of-unity">Roots of unity</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#practice-problems">Practice problems</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">2.2</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">2.4</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">2.5</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">2.6</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sum-of-n-th-roots-of-unity">2.7 Sum of <span class="math notranslate nohighlight">\(n\)</span>-th roots of unity</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">2.12</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#removing-duplicates">2.14 Removing duplicates</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#in-place-split">2.15 In-place split</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-i-i">2.17 <span class="math notranslate nohighlight">\(A[i]=i\)</span></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">2.18</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id20">2.19</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id21">2.20</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#selection-with-two-sorted-lists">2.22 Selection with two sorted lists</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Amanuel Anteneh
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>