
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Divide &amp; conquer &#8212; Amanuel&#39;s Notebook</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=87e54e7c" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'computerscience/algorithms/divide_conquer';</script>
    <link rel="icon" href="../../_static/favicon.png"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Dynamic programming" href="dynamic_prog.html" />
    <link rel="prev" title="Number-theoretic algorithms" href="numerical_algos.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
  
    <p class="title logo__title">Amanuel's Notebook</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Introduction
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Physics</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../physics/intro.html">1. Introduction</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../physics/quantum-mechanics/quantum_mechanics.html">2. Quantum Mechanics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/entanglement.html">Entanglement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/density_matrix.html">Density matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/partial_trace.html">Partial trace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/wigner_function.html">Wigner function</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/gaussian_quantum_info.html">Gaussian quantum information</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/homodyne_detection.html">Homodyne detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/photon_number_detection.html">Photon number detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/lindblad_eq.html">Lindblad master equation</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../physics/classical-mech/classical_mech.html">3. Classical Mechanics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../physics/classical-mech/calc_of_var.html">Calculus of variations</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../physics/e-and-m/e_and_m.html">4. Electricity &amp; Magnetism</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../physics/e-and-m/gauss_law.html">Gauss’s law</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../physics/stat-mech/stat_mech.html">5. Statistical Mechanics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../physics/stat-mech/partition_func.html">Partition function</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/stat-mech/grand_can_ens.html">Grand canonical ensemble</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Computer Science</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">6. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data_structs.html">7. Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lazy_eval.html">8. Lazy Evaluation</a></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="algorithms.html">9. Algorithms</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="numerical_algos.html">Number-theoretic algorithms</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Divide &amp; conquer</a></li>
<li class="toctree-l2"><a class="reference internal" href="dynamic_prog.html">Dynamic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="graph_algos.html">Graph algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="max_flow.html">Max flow algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="np_problems.html">NP-completeness</a></li>
<li class="toctree-l2"><a class="reference internal" href="linear_prog.html">Linear programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="greedy_algos.html">Greedy algorithms</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../optimization/optimization.html">10. Optimization</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../optimization/semidef_prog.html">Semidefinite programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../optimization/quad_prog.html">Quadratic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../optimization/bayes_opt.html">Bayesian optimization</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../machine-learning/machine_learning.html">11. Machine Learning</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/lin_reg.html">Linear regression</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/tree_based.html">Tree-based models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/boosting.html">Boosting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/kernel_machines.html">Kernel machines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/discriminative.html">Discriminative models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/generative.html">Generative models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/cross_ent_loss.html">Cross entropy loss</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/attention.html">Attention</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../deep-learning/deep_learning.html">12. Deep Learning</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../deep-learning/conv_net.html">Convolutional neural network</a></li>
<li class="toctree-l2"><a class="reference internal" href="../deep-learning/rnn.html">Recurrent neural network</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../reinforcement-learning/reinforcement_learning.html">13. Reinforcement Learning</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../reinforcement-learning/ppo.html">Proximal policy optimization</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../quantum-comp/quantum_comp.html">14. Quantum Computing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../quantum-comp/bern_vazirani.html">Bernstein–Vazirani algorithm</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Mathematics</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../mathematics/intro.html">15. Introduction</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/vector-calc/vector_calc.html">16. Vector Calculus</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/vector-calc/gradient.html">Gradient</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/abstract-algebra/algebra.html">17. Abstract Algebra</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/abstract-algebra/group_theory.html">Group theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/abstract-algebra/representation_theory.html">Representation theory</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/linear-algebra/linear_algebra.html">18. Linear Algebra</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/linear-algebra/change_basis.html">Change of basis</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/matrix-calc/matrix_calc.html">19. Matrix Calculus</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/matrix-calc/vec_mat_deriv.html">Vector and matrix derivatives</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/stoc-calc/stoc_calc.html">20. Stochastic Calculus</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/stoc-calc/stoc_diff_eq.html">Stochastic differential equations</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/differential-equations/diff_eq.html">21. Differential Equations</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/differential-equations/wave_eq.html">Wave equation</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/complex-analysis/complex_analysis.html">22. Complex Analysis</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/complex-analysis/contour_int.html">Contour integration</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/probability/probability.html">23. Probability Theory</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/probability/conditioning.html">Conditional distributions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/probability/joint.html">Joint distributions</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Statistics</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../statistics/intro.html">24. Introduction</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../statistics/classic-stats/classic_stats.html">25. Classical Statistics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/classic-stats/conf_int.html">Confidence intervals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/classic-stats/pca.html">Principal component analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/classic-stats/bootstrap.html">Bootstrapping</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../statistics/hypo-testing/hypo_testing.html">26. Hypothesis Testing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/hypo-testing/1_samp_t_test.html">One sample <span class="math notranslate nohighlight">\(t\)</span>-test</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../statistics/sampling/sampling_methods.html">27. Sampling Methods</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/sampling/inv_trans_sampling.html">Inverse transform sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/sampling/rejection_sampling.html">Rejection sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/sampling/mcmc.html">Markov chain monte carlo</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../statistics/high-dim-stats/high_dim.html">28. High-Dimensional Statistics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/high-dim-stats/robust_pca.html">Robust principal component analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/high-dim-stats/compress_sense.html">Compressed sensing</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../statistics/bayesian-statistics/bayesian_statistics.html">29. Bayesian Statistics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/bayesian-statistics/cred_int.html">Credible interval</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/bayesian-statistics/hierarchical_models.html">Hierarchical models</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Back Matter</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../backmatter/bibliography.html">30. Bibliography</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/amanuelanteneh/aman-notes" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/amanuelanteneh/aman-notes/issues/new?title=Issue%20on%20page%20%2Fcomputerscience/algorithms/divide_conquer.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/computerscience/algorithms/divide_conquer.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Divide & conquer</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#integer-multiplication">Integer multiplication</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-recurrence-relations">Solving recurrence relations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#substitution">Substitution</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recursion-tree">Recursion-tree</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#master-method">Master method</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#square-matrix-multiplication">Square matrix multiplication</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#naive-matrix-multiplication">Naive matrix multiplication</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#strassens-algorithm">Strassen’s algorithm</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#merge-sort">Merge sort</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#medians">Medians</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#randomized-divide-conquer">Randomized divide &amp; conquer</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tighter-bound">Tighter bound</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#fast-fourier-transform">Fast Fourier transform</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#representations-of-polynomials">Representations of polynomials</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#practice-problems">Practice problems</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">2.1</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">2.5</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">2.7</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">2.14</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="divide-conquer">
<h1>Divide &amp; conquer<a class="headerlink" href="#divide-conquer" title="Link to this heading">#</a></h1>
<p>Divide &amp; conquer is a method for designing algorithms that solve problems by breaking the problem into smaller subproblems and then solving those smaller problems by dividing further until some base case is reached when the problem is small enough. Once the base case is reached we solve that subproblem and then use that solution to solve the larger problem by combining it with solutions to the other smaller subproblems we have solved. Merge sort is a nice example of this that we will go over. As you can probably guess from this description divide &amp; conquer is very closely tied to the concept of recursion.</p>
<section id="integer-multiplication">
<h2>Integer multiplication<a class="headerlink" href="#integer-multiplication" title="Link to this heading">#</a></h2>
<p>The first problem divide &amp; conquer methods are applied to in <span id="id1">[<a class="reference internal" href="../../backmatter/bibliography.html#id29" title="Sanjoy Dasgupta, Christos H Papadimitriou, and Umesh Virkumar Vazirani. Algorithms. McGraw-Hill Higher Education New York, 2008.">Dasgupta <em>et al.</em>, 2008</a>]</span> is integer multiplication.</p>
<p>To multiple two complex numbers <span class="math notranslate nohighlight">\(g=a+ib\)</span> and <span class="math notranslate nohighlight">\(h=c+id\)</span> we compute</p>
<div class="math notranslate nohighlight">
\[
(a+ib)(c+id)= ac-bd + (bc+ad)i
\]</div>
<p>which involves 4 multiplications of real numbers. Carl Gauss, the famous mathematician, discovered that we can actually reduce this to 3 since</p>
<div class="math notranslate nohighlight">
\[
bc+ad = (a+b)(c+d) - ac - bd
\]</div>
<p>our formula now becomes</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
(a+ib)(c+id) &amp;= ac-bd + (bc+ad)i \\
&amp;= ac-bd + ((a+b)(c+d) - ac - bd)i.
\end{align*}
\end{split}\]</div>
<p>It seems like this involves more multiplication but actually we now just need to compute <span class="math notranslate nohighlight">\(ac\)</span>, <span class="math notranslate nohighlight">\(bd\)</span> and <span class="math notranslate nohighlight">\((a+b)(c+d)\)</span> since <span class="math notranslate nohighlight">\(ac\)</span> and <span class="math notranslate nohighlight">\(bd\)</span> appear twice in the expression so we have 3 <em>unique</em> multiplications of real numbers.</p>
<p>This might seem like minimal improvement but lets see what happens when we apply recursion and switch to integer multiplication. Suppose <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(x\)</span> are <span class="math notranslate nohighlight">\(n\)</span>-bit integers where <span class="math notranslate nohighlight">\(n\)</span> is a power of 2. First lets start by splitting <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> into two halves that are <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span> bits each such that</p>
<div class="math notranslate nohighlight">
\[
x = 2^{\frac{n}{2}} x_L + x_R \quad \text{ and } \quad y = 2^{\frac{n}{2}} y_L + y_R.
\]</div>
<p>For example if  <span class="math notranslate nohighlight">\(x=10110110_2\)</span> then <span class="math notranslate nohighlight">\(x_L=1011_2\)</span> and <span class="math notranslate nohighlight">\(x_R=0110_2\)</span> and <span class="math notranslate nohighlight">\(x=(2^{\frac{n}{2}} \times 1011_2) + 0110_2\)</span>, (note the subscript of 2 means the number is written in base 2 i.e. binary).</p>
<div class="dropdown admonition note">
<p class="admonition-title">Note</p>
<p>Note that we multiply the left most bits by <span class="math notranslate nohighlight">\(2^{n/2}\)</span> since these are the <span class="math notranslate nohighlight">\(n/2\)</span> most significant bits since we’re using big endian convention.
As an explicit example for the <span class="math notranslate nohighlight">\(8\)</span>-bit number</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
x &amp;= 182_{10}\\
&amp;=10110110_2 \\ 
&amp;= (1\times2^7)+(0\times2^6)+(1\times2^5)+(1\times2^4)+(0\times2^3)+(1\times2^2)+(1\times2^1)+(0\times2^0)
\end{align*}
\end{split}\]</div>
<p>since the leftmost bits are the most significant we must have <span class="math notranslate nohighlight">\(x_L=2^{4}\times1011_2 =2^{\frac{8}{2}}\left[(1\times2^3)+(0\times2^2)+(1\times2^1)+(1\times2^0)\right]\)</span> if we are to have <span class="math notranslate nohighlight">\(x_R=0110_2\)</span> and satisfy the equation <span class="math notranslate nohighlight">\(x_L+x_R=x\)</span>.</p>
</div>
<p>Now the product of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
xy &amp;= (2^{\frac{n}{2}} x_L + x_R)(2^{\frac{n}{2}} y_L + y_R)  \\
   &amp;= 2^nx_Ly_L + 2^{\frac{n}{2}}(x_Ly_R + x_Ry_L) + x_Ry_R
\end{align*}
\end{split}\]</div>
<p>The addition will take linear time, in the number of bits, and so to will the power of 2 multiplications since it is just a bit shift to the left i.e. <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;&lt;</span> <span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;&lt;</span> <span class="pre">n_2</span></code> in  <code class="docutils literal notranslate"><span class="pre">Python</span></code>. The important operation are the 4 multiplications of the <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span>-bit numbers. Notice that we have <em>divided</em> the problem into 4 subproblems each of which are <em>half</em> the size i.e. <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span>. We can now recursively perform the same routine for the 4 new multiplications which would further divide the problem into subproblem of smaller size.
We can describe the runtime (time complexity) of these recursive algorithms using <em>recurrence relations</em> which we cover in the next section. The recurrence relation for this algorithm is given by</p>
<div class="math notranslate nohighlight">
\[
T(n) = 4T\left(\frac{n}{2}\right) + O(n)
\]</div>
<p>we multiply by 4 since we are creating 4 new subproblems and multiple by <span class="math notranslate nohighlight">\(T\left(\frac{n}{2}\right)\)</span> since the new subproblems have size <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span>. The additional <span class="math notranslate nohighlight">\(O(n)\)</span> is there to capture the linear time complexity of additions and leftward bit shifts. Solving this recurrence relation for <span class="math notranslate nohighlight">\(T(n)\)</span> we get the solution is <span class="math notranslate nohighlight">\(T(n)=O(n^2)\)</span>. This is the same complexity as the grade-school multiplication method so we have no real improvement with this new recursive algorithm.</p>
<p>We can improve this algorithm by using the insight from Gauss that we laid out earlier. Since <span class="math notranslate nohighlight">\(x_Ly_R + x_Ry_L=(x_L+x_R)(y_L+y_R)-x_Ly_L-x_Ry_R\)</span> we can reduce the 4 multiplications needed down to 3 resulting in a more efficient algorithm.</p>
<p>The pseudocode and for the algorithm are given below.</p>
<div class="proof algorithm dropdown admonition" id="gauss-int-mult">
<p class="admonition-title"><span class="caption-number">Algorithm 9.3 </span> (Integer Multiplication)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>procedure</strong> <span class="math notranslate nohighlight">\(\text{gauss_int_mult}(x,y,n)\)</span>:</p>
<p><strong>Inputs</strong> Given <span class="math notranslate nohighlight">\(n\)</span>-bit integers <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span></p>
<p><strong>Output</strong> Their integer product <span class="math notranslate nohighlight">\(xy\)</span></p>
<ol class="arabic simple">
<li><p>if <span class="math notranslate nohighlight">\(n=1\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(xy\)</span></p></li>
</ol>
</li>
<li><p><span class="math notranslate nohighlight">\(x_L = \text{ leftmost } \lceil \frac{n}{2} \rceil \text{ bits of } x\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(x_R = \text{ rightmost } \lfloor \frac{n}{2} \rfloor \text{ bits of } x\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(y_L = \text{ leftmost } \lceil \frac{n}{2} \rceil \text{ bits of } y\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(y_R = \text{ rightmost } \lfloor \frac{n}{2} \rfloor \text{ bits of } y\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(P_1 = \text{fast_int_mult}(x_L,y_L)\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Compute <span class="math notranslate nohighlight">\(x_Ly_L\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(P_2 = \text{fast_int_mult}(x_R,y_R)\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Compute <span class="math notranslate nohighlight">\(x_Ry_R\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(P_3 = \text{fast_int_mult}(x_L+x_R,y_L+y_R)\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Compute <span class="math notranslate nohighlight">\((x_L+x_R)(y_L+y_R)\)</span></p></li>
<li><p>return <span class="math notranslate nohighlight">\(2^{n} P_1 + 2^{n}(P_3 - P_1 - P_2) + P_2\)</span></p></li>
</ol>
</section>
</div><p>The time complexity for this algorithm is given by the recurrence relation</p>
<div class="math notranslate nohighlight">
\[
T(n) = 3T\left(\frac{n}{2}\right) + O(n)
\]</div>
<p>which has the solution <span class="math notranslate nohighlight">\(T(n) = O(n^{1.59})\)</span> which is a very nice improvement.</p>
</section>
<section id="solving-recurrence-relations">
<h2>Solving recurrence relations<a class="headerlink" href="#solving-recurrence-relations" title="Link to this heading">#</a></h2>
<p>A recurrence relation, which we’ll call recurrence for short from now on, is an equation that describes a function in terms of it’s values on other, usually smaller, arguments. To solve these recurrences there are three main methods described below <span id="id2">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span>.</p>
<section id="substitution">
<h3>Substitution<a class="headerlink" href="#substitution" title="Link to this heading">#</a></h3>
<p>Given a recursion based algorithm we guess the solution and use induction to prove it is correct. For example for the recurrence relation</p>
<div class="math notranslate nohighlight">
\[
T(n) = T\left(\frac{4n}{5}\right) + O(n)
\]</div>
</section>
<section id="recursion-tree">
<h3>Recursion-tree<a class="headerlink" href="#recursion-tree" title="Link to this heading">#</a></h3>
<p>Given a recursion based algorithm you draw out a the recursion as a tree with with the number of branches at each node being the number of subproblems being created, the depth being the levels of recursion and the nodes of the tree representing the cost of an operation at that level of recursion. By examining the tree you then attempt to write out the expression for the time complexity by summing up the nodes.</p>
</section>
<section id="master-method">
<h3>Master method<a class="headerlink" href="#master-method" title="Link to this heading">#</a></h3>
<p>Given a recursion based algorithm if we can express it’s runtime as a recurrence of the form</p>
<div class="math notranslate nohighlight">
\[
T(n) = aT\left(\left\lceil\frac{n}{b}\right\rceil\right) + O(n^d)
\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is the size of the initial problem, <span class="math notranslate nohighlight">\(a\)</span> is the number of subproblems that we divide the problem into at each recursion level, <span class="math notranslate nohighlight">\(\frac{n}{b}\)</span> is the size of the subproblems and <span class="math notranslate nohighlight">\(O(n^d)\)</span> is the time needed to combine the solutions of said subproblems into solutions for the larger problems we can use the <em>master theorem</em> to solve the recurrence.</p>
<div class="proof theorem dropdown admonition" id="theorem-1">
<p class="admonition-title"><span class="caption-number">Theorem 9.2 </span> (Master Theorem)</p>
<section class="theorem-content" id="proof-content">
<p>Given the recurrence</p>
<div class="math notranslate nohighlight">
\[
T(n) = aT\left(\left\lceil\frac{n}{b}\right\rceil\right) + O(n^d)
\]</div>
<p>the solution <span class="math notranslate nohighlight">\(T(n)\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}
T(n) = \begin{cases}
  O(n^d)  &amp; \text{if } d &gt; \log_b(a)\\
  O(n^d\log(n))  &amp; \text{if } d = \log_b(a)\\
  O(n^{\log_b(a)})  &amp; \text{if } d &lt; \log_b(a)\\
\end{cases}
\end{split}\]</div>
<p>which is very useful. The proof along with the theorem is given in <span id="id3">[<a class="reference internal" href="../../backmatter/bibliography.html#id29" title="Sanjoy Dasgupta, Christos H Papadimitriou, and Umesh Virkumar Vazirani. Algorithms. McGraw-Hill Higher Education New York, 2008.">Dasgupta <em>et al.</em>, 2008</a>]</span>.</p>
</section>
</div></section>
</section>
<section id="square-matrix-multiplication">
<h2>Square matrix multiplication<a class="headerlink" href="#square-matrix-multiplication" title="Link to this heading">#</a></h2>
<section id="naive-matrix-multiplication">
<h3>Naive matrix multiplication<a class="headerlink" href="#naive-matrix-multiplication" title="Link to this heading">#</a></h3>
<p>Let’s go over an example from <span id="id4">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span> now. Let <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> be <span class="math notranslate nohighlight">\(n\times n\)</span> matrices. Their product <span class="math notranslate nohighlight">\(C=AB\)</span> is given by (recall that this is equivalent to taking the dot product between the rows of <span class="math notranslate nohighlight">\(A\)</span> with the columns of <span class="math notranslate nohighlight">\(B\)</span>)</p>
<div class="math notranslate nohighlight">
\[
C_{ij} = \sum_{k=1}^{n} A_{ik}B_{kj}
\]</div>
<p>where <span class="math notranslate nohighlight">\(C_{ij}\)</span> is the element of matrix <span class="math notranslate nohighlight">\(C\)</span> at row <span class="math notranslate nohighlight">\(i\)</span> column <span class="math notranslate nohighlight">\(j\)</span>. The pseudocode for an algorithm that computes this formula is given below.</p>
<p>From the triply nested for-loops we can tell the runtime of this algorithm will be <span class="math notranslate nohighlight">\(\Theta(n^3)\)</span>, since for <span class="math notranslate nohighlight">\(n\)</span> iterations we are performing <span class="math notranslate nohighlight">\(n\)</span> operations <span class="math notranslate nohighlight">\(n\)</span> times.</p>
<p>We can however apply the divide and conquer method to this problem by utilizing <em>matrix partitioning</em>. Recall that for two <span class="math notranslate nohighlight">\(n\times n\)</span> matrices <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>, if <span class="math notranslate nohighlight">\(n\)</span> is even, we can partition the matrices as</p>
<div class="math notranslate nohighlight">
\[\begin{split}
A = \begin{bmatrix}
A_{11} &amp; A_{12}\\
A_{21} &amp; A_{22}
\end{bmatrix} 
\text{ and } 
B = \begin{bmatrix}
B_{11} &amp; B_{12}\\
B_{21} &amp; B_{22}
\end{bmatrix} 
\end{split}\]</div>
<p>where the blocks <span class="math notranslate nohighlight">\(A_{ij}\)</span> and <span class="math notranslate nohighlight">\(B_{ij}\)</span> are simply four <span class="math notranslate nohighlight">\(\frac{n}{2} \times \frac{n}{2}\)</span> square block submatrices. We can now express the matrix product in terms of the standard matrices product formula except this time we treat the block matrices as scalars in a sense</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
AB &amp;= \begin{bmatrix}
A_{11} &amp; A_{12}\\
A_{21} &amp; A_{22}
\end{bmatrix}
\begin{bmatrix}
B_{11} &amp; B_{12}\\
B_{21} &amp; B_{22} 
\end{bmatrix} \\
&amp;= \begin{bmatrix}
A_{11}B_{11} + A_{12}B_{21} &amp;  A_{11}B_{12} + A_{12}B_{22} \\
A_{21}B_{11} + A_{22}B_{21} &amp; A_{21}B_{12} + A_{22}B_{22} 
\end{bmatrix}.
\end{align*}
\end{split}\]</div>
<p>Now we can begin to see how divide and conquer can be applied. Notice that we now have 4 smaller problems now i.e. computing the 4 expressions</p>
<div class="math notranslate nohighlight">
\[\begin{split}
C_{11} = A_{11}B_{11} + A_{12}B_{21}\\
C_{12} = A_{11}B_{12} + A_{12}B_{22}\\
C_{21} = A_{21}B_{11} + A_{22}B_{21}\\
C_{22} = A_{21}B_{12} + A_{22}B_{22} 
\end{split}\]</div>
<p>which involve 4 addition and 8 multiplication of <em>smaller</em> matrices now i.e. matrices of size <span class="math notranslate nohighlight">\(\frac{n}{2}\times \frac{n}{2}\)</span>. The divide and conquer algorithm is given below along with a python implementation of it.</p>
<div class="proof algorithm dropdown admonition" id="naive-mat-mult">
<p class="admonition-title"><span class="caption-number">Algorithm 9.4 </span> (Naive Matrix Multiplication)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>procedure</strong> <span class="math notranslate nohighlight">\(\text{naive_mat_mult}(A,B)\)</span>:</p>
<p><strong>Inputs</strong> Given two <span class="math notranslate nohighlight">\(n\times n\)</span> matrices <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span></p>
<p><strong>Output</strong> Their matrix product <span class="math notranslate nohighlight">\(C=AB\)</span></p>
<ol class="arabic simple">
<li><p>Initialize <span class="math notranslate nohighlight">\(C\)</span> to an all zeros matrix of size <span class="math notranslate nohighlight">\(n\times n\)</span></p></li>
<li><p>for <span class="math notranslate nohighlight">\(i=0\)</span> to <span class="math notranslate nohighlight">\(n\)</span>:</p>
<ol class="arabic simple">
<li><p>for <span class="math notranslate nohighlight">\(j=0\)</span> to <span class="math notranslate nohighlight">\(n\)</span>:</p>
<ol class="arabic simple">
<li><p>for <span class="math notranslate nohighlight">\(k=0\)</span> to <span class="math notranslate nohighlight">\(n\)</span>:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(C[i][j] = C[i][j] + A[i][k] \times B[k][j]\)</span></p></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>return <span class="math notranslate nohighlight">\(C\)</span></p></li>
</ol>
</section>
</div><div class="proof algorithm dropdown admonition" id="d&amp;c-mat-mult">
<p class="admonition-title"><span class="caption-number">Algorithm 9.5 </span> (D&amp;C Matrix Multiplication)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>procedure</strong> <span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A,B,C, n)\)</span>:</p>
<p><strong>Inputs</strong> Given two <span class="math notranslate nohighlight">\(n\times n\)</span> matrices <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> and an all zeros matrix of size <span class="math notranslate nohighlight">\(n\times n\)</span></p>
<p><strong>Output</strong> Their matrix product <span class="math notranslate nohighlight">\(C=AB\)</span></p>
<ol class="arabic simple">
<li><p>if <span class="math notranslate nohighlight">\(n=1\)</span>:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(C[0][0] = C[0][0] + A[0][0]\times B[0][0]\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> These are simply scalars since <span class="math notranslate nohighlight">\(n=1\)</span></p></li>
</ol>
</li>
<li><p>Partition <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(C\)</span> into the 12 <span class="math notranslate nohighlight">\(\frac{n}{2}\times \frac{n}{2}\)</span> matrices <span class="math notranslate nohighlight">\(A_{11},A_{21},A_{21},A_{22},B_{11},B_{21},B_{21},B_{22},C_{11},C_{12},C_{21}\)</span> and <span class="math notranslate nohighlight">\(C_{22}\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Divide step</p></li>
<li><p><span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A_{11},B_{11},C_{11}, \frac{n}{2})\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> This computes <span class="math notranslate nohighlight">\(A_{11}B_{11}\)</span> from <span class="math notranslate nohighlight">\(C_{11} = A_{11}B_{11} + A_{12}B_{21}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A_{12},B_{21},C_{11}, \frac{n}{2})\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> This computes <span class="math notranslate nohighlight">\(A_{12}B_{21}\)</span> from <span class="math notranslate nohighlight">\(C_{11} = A_{11}B_{11} + A_{12}B_{21}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A_{11},B_{12},C_{12}, \frac{n}{2})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A_{12},B_{22},C_{12}, \frac{n}{2})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A_{21},B_{11},C_{21}, \frac{n}{2})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A_{22},B_{21},C_{21}, \frac{n}{2})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A_{21},B_{12},C_{22}, \frac{n}{2})\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\text{dc_mat_mult}(A_{22},B_{22},C_{22}, \frac{n}{2})\)</span></p></li>
</ol>
</section>
</div><div class="cell tag_hide-input tag_hide-output docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input above-output-prompt docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dc_mat_mult</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
       <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
       <span class="k">return</span> <span class="n">C</span>

    <span class="n">n_2</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">A11</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">]</span>
    <span class="n">A12</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">,</span> <span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
    <span class="n">A21</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">]</span>
    <span class="n">A22</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>

    <span class="n">B11</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">]</span>
    <span class="n">B12</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">,</span> <span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
    <span class="n">B21</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">]</span>
    <span class="n">B22</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>

    <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A11</span><span class="p">,</span> <span class="n">B11</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">],</span> <span class="n">n_2</span><span class="p">)</span>
    <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A12</span><span class="p">,</span> <span class="n">B21</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">],</span> <span class="n">n_2</span><span class="p">)</span>
    <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A11</span><span class="p">,</span> <span class="n">B12</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">,</span> <span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">n_2</span><span class="p">)</span>
    <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A12</span><span class="p">,</span> <span class="n">B22</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">,</span> <span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">n_2</span><span class="p">)</span>
    <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A21</span><span class="p">,</span> <span class="n">B11</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">],</span> <span class="n">n_2</span><span class="p">)</span>
    <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A22</span><span class="p">,</span> <span class="n">B21</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_2</span><span class="p">],</span> <span class="n">n_2</span><span class="p">)</span>
    <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A21</span><span class="p">,</span> <span class="n">B12</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">n_2</span><span class="p">)</span>
    <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A22</span><span class="p">,</span> <span class="n">B22</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="n">n_2</span><span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">n_2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">C</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">6</span> <span class="c1"># size of matrix</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

<span class="n">AB</span> <span class="o">=</span> <span class="n">A</span><span class="nd">@B</span> <span class="c1"># compute product with numpy</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">dc_mat_mult</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="c1"># compute product with our algo</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Are the matrices the same?&quot;</span><span class="p">,</span> <span class="s2">&quot;Yes&quot;</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">AB</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;No&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
<details class="hide below-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell output</span>
<span class="expanded">Hide code cell output</span>
</summary>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Are the matrices the same? Yes
</pre></div>
</div>
</div>
</details>
</div>
<p>Now since we divide the problem into 8 subproblems at each recursion (the 8 matrix multiplications of the submatrices) of size <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span> and the operation of partitioning the matrices can be made to have complexity <span class="math notranslate nohighlight">\(O(1)\)</span> if we just keep track of the indices of the submatrices we are working with, instead of creating a whole new set of matrices in memory each time we partition a matrix into blocks which has complexity <span class="math notranslate nohighlight">\(O(n^2)\)</span>, we can characterize the runtime of this algorithm with the recurrence</p>
<div class="math notranslate nohighlight">
\[
T(n) = 8T\left(\frac{n}{2}\right) + O(1).
\]</div>
<p>Using the master theorem we have the solution of this recurrence is <span class="math notranslate nohighlight">\(O(n^3)\)</span> so not an asymptotic improvement over the naive method but a useful example of how to use divide and conquer to solve this problem. There is, however, a divide and conquer algorithm for matrix multiplication, devised by Volker Strassen, that is more clever and has better a runtime.</p>
</section>
<section id="strassens-algorithm">
<h3>Strassen’s algorithm<a class="headerlink" href="#strassens-algorithm" title="Link to this heading">#</a></h3>
<p>Strassen’s algorithm achieves a speed up over both the prior methods by utilizing a clever trick akin to the one found by Gauss for integer multiplication. Specifically the algorithm reduces the number of matrix multiplications that need to be computed at each recursion level from 8 to 7! This is done by computing the product as <span id="id5">[<a class="reference internal" href="../../backmatter/bibliography.html#id29" title="Sanjoy Dasgupta, Christos H Papadimitriou, and Umesh Virkumar Vazirani. Algorithms. McGraw-Hill Higher Education New York, 2008.">Dasgupta <em>et al.</em>, 2008</a>]</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}
AB = \begin{bmatrix}
P_5 + P_4 - P_2 + P_6 &amp; P_1 + P_2\\
P_3 + P_4 &amp; P_1 + P_5 - P_3 - P_7
\end{bmatrix}
\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
&amp;P_1=A_{11}(B_{12} - B_{22}), \qquad P_2=(A_{11} + A_{12})B_{22}, \\
&amp;P_3=(A_{21}+A_{22})B_{11}, \qquad P_4=A_{22}(B_{21}+B_{22}), \\
&amp;P_5=(A_{11}+A_{22})(B_{11}+B_{22}), \qquad P_6=(A_{12}-A_{22})(B_{21}+B_{22})\\
&amp;P_7=(A_{11}-A_{21})(B_{11}+B_{12}).
\end{align*}
\end{split}\]</div>
<p>The recurrence for this algorithms time complexity is now given by</p>
<div class="math notranslate nohighlight">
\[
T(n) = 7T\left(\frac{n}{2}\right) + O(1).
\]</div>
<p>and from the master theorem we get the solution to this recurrence is <span class="math notranslate nohighlight">\(T(n)=O(n^{log_{2}(7)}) \approx O(n^{2.807})\)</span>. This may not seem like a huge improvement but as the matrix sizes get large e.g. in the millions, which is this very common for computations in fields such as deep learning, this algorithms runtime is about an order of magnitude faster.</p>
</section>
</section>
<section id="merge-sort">
<h2>Merge sort<a class="headerlink" href="#merge-sort" title="Link to this heading">#</a></h2>
<p>Merge sort is one of the best divide and conquer algorithms for sorting a list of numbers. The idea behind merge sort is you have a list <span class="math notranslate nohighlight">\(L\)</span> of numbers and you go about sorting it by first dividing the list into two halves of equal length. We then recursively sort each half of the list and then merge the two sorted lists. The merge sort algorithm is given below.</p>
<div class="proof algorithm dropdown admonition" id="merge-sort">
<p class="admonition-title"><span class="caption-number">Algorithm 9.6 </span> (Merge sort)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>procedure</strong> <span class="math notranslate nohighlight">\(\text{merge_sort}(L)\)</span>:</p>
<p><strong>Inputs</strong> Given a list <span class="math notranslate nohighlight">\(L[1,...,n]\)</span> of length <span class="math notranslate nohighlight">\(n\)</span></p>
<p><strong>Output</strong> The sorted list <span class="math notranslate nohighlight">\(L\)</span> in ascending order</p>
<ol class="arabic simple">
<li><p>if <span class="math notranslate nohighlight">\(n&gt;1\)</span>: <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Divide <span class="math notranslate nohighlight">\(L\)</span> into two smaller lists</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(L_1  = L\left[1,...,\lfloor\frac{n}{2}\rfloor\right]\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Get first <span class="math notranslate nohighlight">\(\lfloor\frac{n}{2}\rfloor\)</span> elements</p></li>
<li><p><span class="math notranslate nohighlight">\(L_2  = L\left[\lfloor\frac{n}{2}\rfloor+1,...,n\right]\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Get last <span class="math notranslate nohighlight">\(\lfloor\frac{n}{2}\rfloor\)</span> elements</p></li>
<li><p>return <span class="math notranslate nohighlight">\(\text{merge}( \text{merge_sort}(L_1),  \text{ merge_sort}(L_2) )\)</span></p></li>
</ol>
</li>
<li><p>else: <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> When list has only 1 element return the element</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(L[1]\)</span></p></li>
</ol>
</li>
</ol>
<p><strong>procedure</strong> <span class="math notranslate nohighlight">\(\text{merge}(L_1, L_2)\)</span>:</p>
<p><strong>Inputs</strong> Given 2 lists <span class="math notranslate nohighlight">\(L_1[1,...,n]\)</span> and <span class="math notranslate nohighlight">\(L_2[1,...,m]\)</span> of length <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(m\)</span> respectively sorted in ascending order.</p>
<p><strong>Output</strong> The  combined list <span class="math notranslate nohighlight">\(L\)</span> sorted in ascending order</p>
<ol class="arabic simple">
<li><p>if <span class="math notranslate nohighlight">\(n=0\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(L_2[1,...,m]\)</span></p></li>
</ol>
</li>
<li><p>if <span class="math notranslate nohighlight">\(m=0\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(L_1[1,...,n]\)</span></p></li>
</ol>
</li>
<li><p>if <span class="math notranslate nohighlight">\(L_1[1] \leq L_2[1]\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(L_1[1] \oplus \text{merge}(L_1[2,...,n], L_2[1,...,m])\)</span></p></li>
</ol>
</li>
<li><p>else:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(L_2[1] \oplus \text{merge}(L_2[1,...,n], L_2[2,...,m])\)</span></p></li>
</ol>
</li>
</ol>
<p>Note <span class="math notranslate nohighlight">\(L_1[1] \oplus \text{merge}(L_1[2,...,n], L_2[1,...,m])\)</span> means we concatenate the list returned from the <span class="math notranslate nohighlight">\(\text{merge}\)</span> call to the end of the one element list <span class="math notranslate nohighlight">\(L_1[1]\)</span>.</p>
</section>
</div><p>Now the <span class="math notranslate nohighlight">\(\text{merge}\)</span> function is the crucial component here as it defines how we combine the resulting sorted lists. Let’s think about how we would combine two sorted (ascending order) lists <span class="math notranslate nohighlight">\(L_1\)</span> and <span class="math notranslate nohighlight">\(L_2\)</span> into a list <span class="math notranslate nohighlight">\(L\)</span>. Well since both lists are sorted when now that the first element of the combined list will either be the first element of <span class="math notranslate nohighlight">\(L_1\)</span> or the first element of <span class="math notranslate nohighlight">\(L_2\)</span>. But why are we assuming the lists are sorted? It isn’t super clear where the lists are getting sorted in the first place. So the key thing to think about is the case where <span class="math notranslate nohighlight">\(\text{merge_sort}\)</span>’s base case is reached. When this happens we just return a a list with one element. Once this happens we start to recurse back up the recursion tree. So the <span class="math notranslate nohighlight">\(\text{merge}\)</span> function is called with the input lists being single element lists. At that point we just compare the elements in both lists and concatenate them based on which is smaller as is done by the last two conditional statements in the <span class="math notranslate nohighlight">\(\text{merge}\)</span> function. After this we move up one level in the recursion tree <span class="math notranslate nohighlight">\(\text{merge}\)</span> is called again but this time the lists have length 2. So we can see that once we get to the top of the recursion tree we will have two list whose sizes, <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(m\)</span> respectively, add up to the size adds up to the length of the original input list. Clearly the <span class="math notranslate nohighlight">\(\text{merge}\)</span> function compares the first element of <span class="math notranslate nohighlight">\(L_1\)</span> with the first element of <span class="math notranslate nohighlight">\(L_2\)</span> and then compares the second element of <span class="math notranslate nohighlight">\(L_1\)</span> with the second element of <span class="math notranslate nohighlight">\(L_2\)</span> and so on. This means <span class="math notranslate nohighlight">\(\text{merge}\)</span> does <span class="math notranslate nohighlight">\(O(n+m)\)</span> operations meaning the time for the merge step is linear in the size of the two lists. So we take a problem of size <span class="math notranslate nohighlight">\(n\)</span> and divide it into two subproblems of size <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span> and solve each of these subproblems in time <span class="math notranslate nohighlight">\(O(n)\)</span> thus the runtime of merge sort is characterized by the recurrence</p>
<div class="math notranslate nohighlight">
\[
T(n) = 2T\left(\frac{n}{2}\right) + O(n)
\]</div>
<p>from the master theorem we have that the solution to this recurrence is <span class="math notranslate nohighlight">\(T(n)=O(n\log(n))\)</span> which means we can sort a list in time that is log-linear in the size of the list. Not bad and in fact this is, provably, the best we can do for a <em>comparison based</em> sorting algorithm <span id="id6">[<a class="reference internal" href="../../backmatter/bibliography.html#id29" title="Sanjoy Dasgupta, Christos H Papadimitriou, and Umesh Virkumar Vazirani. Algorithms. McGraw-Hill Higher Education New York, 2008.">Dasgupta <em>et al.</em>, 2008</a>]</span>. See radix sort for a non-comparison based sorting algorithm with complexity <span class="math notranslate nohighlight">\(O(n)\)</span> <span id="id7">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span>.</p>
</section>
<section id="medians">
<h2>Medians<a class="headerlink" href="#medians" title="Link to this heading">#</a></h2>
<p>We will now look at how to find the median of a list of <em>unsorted</em> (unsorted because if the list was sorted the problem would be trivial) numbers using the divide &amp; conquer method. The median of a set of numbers is of course the number that is smaller than 50% of the numbers in the list and greater than or equal to the other 50% of the numbers in the list. To devise an algorithm for this problem it is actually useful to generalize it. The median, for a list of size <span class="math notranslate nohighlight">\(n\)</span>, can also be thought of as the <span class="math notranslate nohighlight">\(\lfloor\frac{n}{2}\rfloor\)</span>-th smallest number in the list. So perhaps we should generalize this problem into finding the <span class="math notranslate nohighlight">\(k\)</span>-th smallest number in a list of numbers and we’ll call this problem <em>selection</em>.</p>
<section id="randomized-divide-conquer">
<h3>Randomized divide &amp; conquer<a class="headerlink" href="#randomized-divide-conquer" title="Link to this heading">#</a></h3>
<p>So how can we devise an algorithm to find the <span class="math notranslate nohighlight">\(k\)</span>-th smallest number in an unsorted list <span class="math notranslate nohighlight">\(L\)</span>? Suppose we take a number <span class="math notranslate nohighlight">\(w\)</span> and split <span class="math notranslate nohighlight">\(L\)</span> into 3 lists: <span class="math notranslate nohighlight">\(L_l\)</span> which is the list of elements in <span class="math notranslate nohighlight">\(L\)</span> that are less than <span class="math notranslate nohighlight">\(w\)</span>, <span class="math notranslate nohighlight">\(L_w\)</span> the list of elements in <span class="math notranslate nohighlight">\(L\)</span> that are equal to <span class="math notranslate nohighlight">\(w\)</span> and <span class="math notranslate nohighlight">\(L_g\)</span> which is the list of elements in <span class="math notranslate nohighlight">\(L\)</span> that are greater than <span class="math notranslate nohighlight">\(w\)</span>. As an example lets take the following list</p>
<div class="math notranslate nohighlight">
\[
L = [2, 36, 5, 21, 8, 13, 11, 20, 5, 4, 1]
\]</div>
<p>and take <span class="math notranslate nohighlight">\(w=5\)</span>. We would then split the list into</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
L_l &amp;= [2, 4, 1] \\ L_w &amp;= [5,5] \\ L_g &amp;= [36, 21, 8, 13, 11, 20].
\end{align*}
\end{split}\]</div>
<p>Now suppose we want the 8th smallest element of <span class="math notranslate nohighlight">\(L\)</span>. We know that this would be the 3rd smallest element of <span class="math notranslate nohighlight">\(L_g\)</span>. Why? Think of it like this: Where is the smallest element? Well it’s certainly in <span class="math notranslate nohighlight">\(L_l\)</span> since that is the list with all elements smaller than <span class="math notranslate nohighlight">\(w\)</span>. Where is the second smallest element? Also in <span class="math notranslate nohighlight">\(L_l\)</span>. The third smallest element is also in <span class="math notranslate nohighlight">\(L_l\)</span>. Now what about the fourth smallest? Well that would be in <span class="math notranslate nohighlight">\(L_w\)</span> since the first 3 smallest elements are in <span class="math notranslate nohighlight">\(L_l\)</span>. What about the sixth smallest element? Well it can’t be in <span class="math notranslate nohighlight">\(L_l\)</span> since that contains the first 3 smallest, and it can’t be in <span class="math notranslate nohighlight">\(L_w\)</span> since that contains the next 2 smallest so it must be in <span class="math notranslate nohighlight">\(L_g\)</span>, and more importantly it will be the smallest number in <span class="math notranslate nohighlight">\(L_g\)</span>. The seventh smallest number can be found in the same way except this time it will be the <em>second</em> smallest element in <span class="math notranslate nohighlight">\(L_g\)</span>. So to put it in general terms if we want the <span class="math notranslate nohighlight">\(k\)</span>-th smallest element if <span class="math notranslate nohighlight">\(k \leq |L_l|\)</span> then we know the <span class="math notranslate nohighlight">\(k\)</span>-th smallest element is in <span class="math notranslate nohighlight">\(L_l\)</span> and we can simply ignore the other two list. If <span class="math notranslate nohighlight">\(k &gt; |L_l|+|L_w|\)</span> then we know the <span class="math notranslate nohighlight">\(k\)</span>-th smallest element is in <span class="math notranslate nohighlight">\(L_g\)</span>. And if neither condition is true then that means <span class="math notranslate nohighlight">\(|L_s|&lt;k\leq |L_l|+|L_w|\)</span> which means the element we want is in <span class="math notranslate nohighlight">\(L_w\)</span> i.e. the element is <span class="math notranslate nohighlight">\(w\)</span> itself. The pseudocode is given below.</p>
<div class="proof algorithm dropdown admonition" id="selection (Linear Expected Case Time)">
<p class="admonition-title"><span class="caption-number">Algorithm 9.7 </span> (Selection - <span class="math notranslate nohighlight">\(O(n)\)</span> Expected Case Time)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>procedure</strong> <span class="math notranslate nohighlight">\(\text{selection}(L, k)\)</span>:</p>
<p><strong>Inputs</strong> Given a list <span class="math notranslate nohighlight">\(L[1,...,n]\)</span> of length <span class="math notranslate nohighlight">\(n\)</span> and an integer <span class="math notranslate nohighlight">\(1\leq k \leq n\)</span></p>
<p><strong>Output</strong> The <span class="math notranslate nohighlight">\(k\)</span>-th smallest element in the list</p>
<ol class="arabic simple">
<li><p>Select pivot element <span class="math notranslate nohighlight">\(w\)</span> by randomly sampling uniformly from <span class="math notranslate nohighlight">\(L\)</span></p></li>
<li><p>Divide <span class="math notranslate nohighlight">\(L\)</span> into the lists <span class="math notranslate nohighlight">\(L_l\)</span>, <span class="math notranslate nohighlight">\(L_w\)</span> and <span class="math notranslate nohighlight">\(L_g\)</span></p></li>
<li><p>if <span class="math notranslate nohighlight">\(k \leq |L_l|\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(\text{selection}(L_l, k)\)</span></p></li>
</ol>
</li>
<li><p>if <span class="math notranslate nohighlight">\(k &gt; |L_l| + |L_w|\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(\text{selection}(L_g, k-|L_l| - |L_w|)\)</span></p></li>
</ol>
</li>
<li><p>else:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(w\)</span></p></li>
</ol>
</li>
</ol>
</section>
</div><p>Now what about the time complexity of this algorithm? Well if we assume that the size of <span class="math notranslate nohighlight">\(L_l\)</span> and <span class="math notranslate nohighlight">\(L_g\)</span> are roughly equal to <span class="math notranslate nohighlight">\(\frac{1}{2}|L|\)</span> at each divide step then we are dividing the problem into a subproblem of half the size <em>but</em> we must note that the process of splitting the list into the three sublists takes linear time in the number of elements since we must compare each of the <span class="math notranslate nohighlight">\(n\)</span> elements with <span class="math notranslate nohighlight">\(w\)</span> to decide which list it should go into. So the recurrence for this algorithm is given by</p>
<div class="math notranslate nohighlight">
\[
T(n) = T\left(\frac{n}{2}\right) + O(n)
\]</div>
<p>which from the master theorem has the solution <span class="math notranslate nohighlight">\(O(n)\)</span>! This is a great solution but it relies on a rather strong assumption: that we choose a value of <span class="math notranslate nohighlight">\(w\)</span> that creates list <span class="math notranslate nohighlight">\(L_l\)</span> and <span class="math notranslate nohighlight">\(L_g\)</span> which have size roughly equal to <span class="math notranslate nohighlight">\(\frac{1}{2}\)</span> the size of the original list. But we don’t really have a way of selecting <span class="math notranslate nohighlight">\(w\)</span> that guarantees this to be the case every time. And in fact if we did have such a method of picking <span class="math notranslate nohighlight">\(w\)</span> then we could just use that method to find the median since the value of <span class="math notranslate nohighlight">\(w\)</span> that would divide the list into lists <span class="math notranslate nohighlight">\(L_l\)</span> and <span class="math notranslate nohighlight">\(L_g\)</span> of <span class="math notranslate nohighlight">\(\frac{n}{2}\)</span> size is the median! What if we just pick <span class="math notranslate nohighlight">\(w\)</span> randomly (hence why this is a randomized divide &amp; conquer algorithm)? The worst case scenario here is that we want to run the algorithm for <span class="math notranslate nohighlight">\(k=1\)</span>, so we want the smallest element in the list, and pick a <span class="math notranslate nohighlight">\(w\)</span> that is the largest element in the list each time which would only reduce the size of the list by one at each recursive call. This means we would end up doing <span class="math notranslate nohighlight">\(n\)</span> recursive calls and <span class="math notranslate nohighlight">\(n-i\)</span> comparisons at each call where <span class="math notranslate nohighlight">\(i\)</span> is the recursion level we are on. We would thus do</p>
<div class="math notranslate nohighlight">
\[
\sum^{n}_{i=1}(n-i) 
\]</div>
<p>total comparisons which by induction can be shown to be equal to <span class="math notranslate nohighlight">\(\frac{n(n-1)}{2}\)</span> for <span class="math notranslate nohighlight">\(n \in \mathbb{Z^+}\)</span> so our worst case time complexity is <span class="math notranslate nohighlight">\(O(n^2)\)</span> which is the time a naive approach of just comparing each element with every other one would take to find the median. However the chance that we pick badly like this at every step is incredibly low. For example the chance that we pick the largest element in a list <span class="math notranslate nohighlight">\(n\)</span> elements, assuming each element is equally likely to be chosen, is <span class="math notranslate nohighlight">\(\frac{1}{n}\)</span>. The chance that we do it again once that element is removed is <span class="math notranslate nohighlight">\(\frac{1}{n-1}\)</span> and so on until we get to a list of only one element. That means the probability of this worst case scenario occurring is</p>
<div class="math notranslate nohighlight">
\[
\prod_{i=0}^{n-1}\frac{1}{n-i} = \frac{1}{n!}
\]</div>
<p>which very quickly approaches 0 as <span class="math notranslate nohighlight">\(n\)</span> increases.</p>
<p>But this is just the absolute worse case; it would be more useful to know the time complexity for the case where we pick a pivot that is somewhat good. For example what if we pick a <span class="math notranslate nohighlight">\(w\)</span> which creates lists of size <span class="math notranslate nohighlight">\(\frac{3n}{4}\)</span> that we then recursively run the algorithm on? Well in that case the recurrence is given by</p>
<div class="math notranslate nohighlight">
\[
T(n) = T\left(\frac{3n}{4}\right) + O(n)
\]</div>
<p>and if we use the master theorem we will come to the surprising conclusion that the solution to this recurrence is also <span class="math notranslate nohighlight">\(O(n)\)</span> and in fact is <span class="math notranslate nohighlight">\(O(n)\)</span> for any recurrence relation of the form</p>
<div class="math notranslate nohighlight">
\[
T(n) = T\left(an\right) + O(n)
\]</div>
<p>where <span class="math notranslate nohighlight">\(a&lt;1\)</span>! So this means we have some leeway in picking <span class="math notranslate nohighlight">\(w\)</span>. If we can find a way to pick a <span class="math notranslate nohighlight">\(w\)</span> that is less than the <span class="math notranslate nohighlight">\(\frac{3n}{4}\)</span>-th largest element and greater than the <span class="math notranslate nohighlight">\(\frac{n}{4}\)</span>-th largest we will have an <span class="math notranslate nohighlight">\(O(n)\)</span> algorithm for finding the median of an unsorted list.</p>
<p>How many elements are there in the list that are less than the <span class="math notranslate nohighlight">\(\frac{3n}{4}\)</span>-th largest element and greater than the <span class="math notranslate nohighlight">\(\frac{n}{4}\)</span>-th largest element (note that it doesn’t matter if the list is sorted)? Well thats <span class="math notranslate nohighlight">\(\frac{3n}{4}-\frac{n}{4}=\frac{n}{2}\)</span> elements. So if we pick a pivot randomly that means we have a <span class="math notranslate nohighlight">\(\frac{1}{2}\)</span> chance of picking a pivot that is one of these elements. This means that on average we have to randomly select an element twice to get a good pivot. This is akin to flipping a fair coin where <span id="id8">[<a class="reference internal" href="../../backmatter/bibliography.html#id29" title="Sanjoy Dasgupta, Christos H Papadimitriou, and Umesh Virkumar Vazirani. Algorithms. McGraw-Hill Higher Education New York, 2008.">Dasgupta <em>et al.</em>, 2008</a>]</span> show that on average we must flip the coin two times before we see a heads. Note that once we randomly select a candiadate for the pivot we must check to see it satisfies the condition of being less than the <span class="math notranslate nohighlight">\(\frac{3n}{4}\)</span>-th largest element and greater than the <span class="math notranslate nohighlight">\(\frac{n}{4}\)</span>-th largest element in the list which will take <span class="math notranslate nohighlight">\(O(n)\)</span> time. So on average we will need to do this twice before we have a good pivot so on average we can expect a time complexity of <span class="math notranslate nohighlight">\(O(n)\)</span> when choosing the pivot in this way and thus our recurrence form earlier will describe the runtime of our algorithm.</p>
</section>
<section id="tighter-bound">
<h3>Tighter bound<a class="headerlink" href="#tighter-bound" title="Link to this heading">#</a></h3>
<p>But this is just the <em>expected/average</em> runtime of the algorithm. Can we modify the algorithm to get an even tighter bound that shows that in the <em>worst</em> case we have a complexity of <span class="math notranslate nohighlight">\(O(n)\)</span>? Well it turns out we can by modifying how we select the pivot which is explained by Dr. Vigoda in lecture and in chapter 9 of <span id="id9">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span>.</p>
<p>The key insight is that we want to select the pivot from a sample from the list <span class="math notranslate nohighlight">\(L\)</span>. The</p>
<p>So first we will take <span class="math notranslate nohighlight">\(L\)</span> and divide it into <span class="math notranslate nohighlight">\(\frac{n}{5}\)</span> smaller lists <span class="math notranslate nohighlight">\(G_1,G_2,...,G_{n/5}\)</span> which each have <span class="math notranslate nohighlight">\(5\)</span> elements in them. We will then <em>sort</em> each list. You might think that this ruins our time complexity of <span class="math notranslate nohighlight">\(O(n)\)</span> since (comparison-based) sorting takes <span class="math notranslate nohighlight">\(O(n\log{n})\)</span> time but you would be incorrect. This is because each list has a constant number of elements in it regardless of the input size <span class="math notranslate nohighlight">\(n\)</span> i.e. <span class="math notranslate nohighlight">\(5\)</span> elements. So it in fact takes <span class="math notranslate nohighlight">\(O(1)\)</span> time to sort each list! Once each <span class="math notranslate nohighlight">\(G_i\)</span> is sorted we find its median, <span class="math notranslate nohighlight">\(m_i\)</span>, which takes <span class="math notranslate nohighlight">\(O(1)\)</span> time since the list is sorted (just look at the middle element) and create a list of these medians <span class="math notranslate nohighlight">\(S=[m_1,m_2,...m_{n/5}]\)</span>. We will then select our pivot from this list by finding it’s median by <em>recursively calling the selection algorithm on it</em> with <span class="math notranslate nohighlight">\(k=\frac{n}{10}\)</span>.</p>
<p>Why is the median of <span class="math notranslate nohighlight">\(S\)</span> the <span class="math notranslate nohighlight">\(\frac{n}{10}\)</span>-th smallest element of <span class="math notranslate nohighlight">\(S\)</span>? Because</p>
<div class="proof algorithm dropdown admonition" id="selection $O(n)$ Worst Case Time">
<p class="admonition-title"><span class="caption-number">Algorithm 9.8 </span> (Selection - <span class="math notranslate nohighlight">\(O(n)\)</span> Worst Case Time)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>procedure</strong> <span class="math notranslate nohighlight">\(\text{selection}(L, k)\)</span>:</p>
<p><strong>Inputs</strong> Given a list <span class="math notranslate nohighlight">\(L[1,...,n]\)</span> of length <span class="math notranslate nohighlight">\(n\)</span> and an integer <span class="math notranslate nohighlight">\(1\leq k \leq n\)</span></p>
<p><strong>Output</strong> The <span class="math notranslate nohighlight">\(k\)</span>-th smallest element in the list</p>
<ol class="arabic simple">
<li><p>Break <span class="math notranslate nohighlight">\(L\)</span> into <span class="math notranslate nohighlight">\(\frac{n}{5}\)</span> groups, <span class="math notranslate nohighlight">\(G_1,G_2,...,G_{n/5}\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Lines 1-4 are for selecting the pivot <span class="math notranslate nohighlight">\(w\)</span></p></li>
<li><p>For <span class="math notranslate nohighlight">\(i=1\)</span> to <span class="math notranslate nohighlight">\(\frac{n}{5}\)</span>:</p>
<ol class="arabic simple">
<li><p>Sort <span class="math notranslate nohighlight">\(G_i\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Sort each <span class="math notranslate nohighlight">\(G_i\)</span></p></li>
<li><p>Set <span class="math notranslate nohighlight">\(m_i=\text{median}(G_i)\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Set <span class="math notranslate nohighlight">\(m_i\)</span> to median of sorted list <span class="math notranslate nohighlight">\(G_i\)</span></p></li>
</ol>
</li>
<li><p><span class="math notranslate nohighlight">\(S=[m_1,m_2,...,m_{n/5}]\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Create new list of median values</p></li>
<li><p><span class="math notranslate nohighlight">\(w = \text{selection}(S, \frac{n}{10})\)</span> <span class="math notranslate nohighlight">\(\quad \triangleright\)</span> Recursively call algorithm to select a good pivot from this sample</p></li>
<li><p>Divide <span class="math notranslate nohighlight">\(L\)</span> into the lists <span class="math notranslate nohighlight">\(L_l\)</span>, <span class="math notranslate nohighlight">\(L_w\)</span> and <span class="math notranslate nohighlight">\(L_g\)</span></p></li>
<li><p>if <span class="math notranslate nohighlight">\(k \leq |L_l|\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(\text{selection}(L_l, k)\)</span></p></li>
</ol>
</li>
<li><p>if <span class="math notranslate nohighlight">\(k &gt; |L_l| + |L_w|\)</span>:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(\text{selection}(L_g, k-|L_l| - |L_w|)\)</span></p></li>
</ol>
</li>
<li><p>else:</p>
<ol class="arabic simple">
<li><p>return <span class="math notranslate nohighlight">\(w\)</span></p></li>
</ol>
</li>
</ol>
</section>
</div></section>
</section>
<section id="fast-fourier-transform">
<h2>Fast Fourier transform<a class="headerlink" href="#fast-fourier-transform" title="Link to this heading">#</a></h2>
<p>The fast (discrete) Fourier transform (FFT) is an algorithm that has revolutionized signal processing. <span id="id10">[<a class="reference internal" href="../../backmatter/bibliography.html#id29" title="Sanjoy Dasgupta, Christos H Papadimitriou, and Umesh Virkumar Vazirani. Algorithms. McGraw-Hill Higher Education New York, 2008.">Dasgupta <em>et al.</em>, 2008</a>]</span> explains how one can</p>
<p>The continuous time Fourier transform, Fourier transform for short, of a function <span class="math notranslate nohighlight">\(x(t)\)</span>, denoted as <span class="math notranslate nohighlight">\(\hat{x}(f)\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[
\hat{x}(f) = \int_{-\infty}^{\infty}x(t)e^{-i2\pi f t}dt
\]</div>
<p>and the discrete time Fourier transform of a function <span class="math notranslate nohighlight">\(x(t)\)</span>, denoted as <span class="math notranslate nohighlight">\(\hat{x}(f)\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[
\hat{x}(f) = \sum_{n=-\infty}^{\infty}x[n]e^{-i2\pi f t}.
\]</div>
<p>The <em>discrete</em> Fourier transform transforms a discrete sequence of complex numbers <span class="math notranslate nohighlight">\(\{x_0,x_1,...,x_{N-1}\}\)</span> into another discrete sequence of complex numbers
<span class="math notranslate nohighlight">\(\{X_0, X_1,...,X_{N-1}\}\)</span> such that</p>
<div class="math notranslate nohighlight">
\[
X_k = \sum_{n=0}^{N-1}x_n e^{-i2\pi k n /N}.
\]</div>
<p>For the FFT we are interested in</p>
<section id="representations-of-polynomials">
<h3>Representations of polynomials<a class="headerlink" href="#representations-of-polynomials" title="Link to this heading">#</a></h3>
</section>
</section>
<section id="practice-problems">
<h2>Practice problems<a class="headerlink" href="#practice-problems" title="Link to this heading">#</a></h2>
<section id="id11">
<h3>2.1<a class="headerlink" href="#id11" title="Link to this heading">#</a></h3>
</section>
<section id="id12">
<h3>2.5<a class="headerlink" href="#id12" title="Link to this heading">#</a></h3>
</section>
<section id="id13">
<h3>2.7<a class="headerlink" href="#id13" title="Link to this heading">#</a></h3>
</section>
<section id="id14">
<h3>2.14<a class="headerlink" href="#id14" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">load_ext</span> watermark
<span class="o">%</span><span class="k">watermark</span> -n -u -v -iv
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Last updated: Sun Jul 14 2024

Python implementation: CPython
Python version       : 3.10.12
IPython version      : 8.22.2
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./computerscience/algorithms"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="numerical_algos.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Number-theoretic algorithms</p>
      </div>
    </a>
    <a class="right-next"
       href="dynamic_prog.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Dynamic programming</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#integer-multiplication">Integer multiplication</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-recurrence-relations">Solving recurrence relations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#substitution">Substitution</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recursion-tree">Recursion-tree</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#master-method">Master method</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#square-matrix-multiplication">Square matrix multiplication</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#naive-matrix-multiplication">Naive matrix multiplication</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#strassens-algorithm">Strassen’s algorithm</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#merge-sort">Merge sort</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#medians">Medians</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#randomized-divide-conquer">Randomized divide &amp; conquer</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tighter-bound">Tighter bound</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#fast-fourier-transform">Fast Fourier transform</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#representations-of-polynomials">Representations of polynomials</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#practice-problems">Practice problems</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">2.1</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">2.5</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">2.7</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">2.14</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Amanuel Anteneh
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>