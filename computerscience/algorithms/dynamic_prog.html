
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Dynamic programming &#8212; Amanuel&#39;s Notebook</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=87e54e7c" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'computerscience/algorithms/dynamic_prog';</script>
    <link rel="icon" href="../../_static/favicon.png"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Graph algorithms" href="graph_algos.html" />
    <link rel="prev" title="Divide &amp; conquer" href="divide_conquer.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
  
    <p class="title logo__title">Amanuel's Notebook</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Introduction
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Physics</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../physics/intro.html">1. Introduction</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../physics/quantum-mechanics/quantum_mechanics.html">2. Quantum Mechanics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/entanglement.html">Entanglement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/density_matrix.html">Density matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/partial_trace.html">Partial trace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/wigner_function.html">Wigner function</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/gaussian_quantum_info.html">Gaussian quantum information</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/homodyne_detection.html">Homodyne detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/photon_number_detection.html">Photon number detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/lindblad_eq.html">Lindblad master equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/quantum-mechanics/cv_qc_examples.html">CV QC simulations</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../physics/classical-mech/classical_mech.html">3. Classical Mechanics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../physics/classical-mech/calc_of_var.html">Calculus of variations</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../physics/e-and-m/e_and_m.html">4. Electricity &amp; Magnetism</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../physics/e-and-m/gauss_law.html">Gauss’s law</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../physics/stat-mech/stat_mech.html">5. Statistical Mechanics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../physics/stat-mech/partition_func.html">Partition function</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../physics/stat-mech/grand_can_ens.html">Grand canonical ensemble</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Mathematics</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../mathematics/intro.html">6. Introduction</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/vector-calc/vector_calc.html">7. Vector Calculus</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/vector-calc/gradient.html">Gradient</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/discrete-math/discrete_math.html">8. Discrete Mathematics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/discrete-math/sets.html">Set theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/discrete-math/relations.html">Relations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/discrete-math/graph_theory.html">Graph theory</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/abstract-algebra/algebra.html">9. Abstract Algebra</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/abstract-algebra/group_theory.html">Group theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/abstract-algebra/representation_theory.html">Representation theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/abstract-algebra/bch.html">Baker–Campbell–Hausdorff formula</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/linear-algebra/linear_algebra.html">10. Linear Algebra</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/linear-algebra/change_basis.html">Change of basis</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/matrix-calc/matrix_calc.html">11. Matrix Calculus</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/matrix-calc/vec_mat_deriv.html">Vector and matrix derivatives</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/stoc-calc/stoc_calc.html">12. Stochastic Calculus</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/stoc-calc/stoc_diff_eq.html">Stochastic differential equations</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/differential-equations/diff_eq.html">13. Differential Equations</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/differential-equations/wave_eq.html">Wave equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/differential-equations/laplace_eq.html">Lapalace’s equation</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/complex-analysis/complex_analysis.html">14. Complex Analysis</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/complex-analysis/contour_int.html">Contour integration</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematics/probability/probability.html">15. Probability Theory</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/probability/conditioning.html">Conditional distributions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mathematics/probability/joint.html">Joint distributions</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Computer Science</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">16. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data_structs.html">17. Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lazy_eval.html">18. Lazy Evaluation</a></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="algorithms.html">19. Algorithms</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="numerical_algos.html">Number-theoretic algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="divide_conquer.html">Divide &amp; conquer</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Dynamic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="graph_algos.html">Graph algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="greedy_algos.html">Greedy algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="np_problems.html">Computational complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="linear_prog.html">Linear programming</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../optimization/optimization.html">20. Optimization</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../optimization/semidef_prog.html">Semidefinite programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../optimization/quad_prog.html">Quadratic programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../optimization/bayes_opt.html">Bayesian optimization</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../machine-learning/machine_learning.html">21. Machine Learning</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/lin_reg.html">Linear regression</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/tree_based.html">Tree-based models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/boosting.html">Boosting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/kernel_machines.html">Kernel machines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/discriminative.html">Discriminative models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/generative.html">Generative models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/cross_ent_loss.html">Cross entropy loss</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/attention.html">Attention</a></li>
<li class="toctree-l2"><a class="reference internal" href="../machine-learning/physical_learning.html">Physical learning</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../deep-learning/deep_learning.html">22. Deep Learning</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../deep-learning/conv_net.html">Convolutional neural network</a></li>
<li class="toctree-l2"><a class="reference internal" href="../deep-learning/rnn.html">Recurrent neural network</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../reinforcement-learning/reinforcement_learning.html">23. Reinforcement Learning</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../reinforcement-learning/ppo.html">Proximal policy optimization</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../quantum-comp/quantum_comp.html">24. Quantum Computing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../quantum-comp/bern_vazirani.html">Bernstein–Vazirani algorithm</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Statistics</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../statistics/intro.html">25. Introduction</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../statistics/classic-stats/classic_stats.html">26. Classical Statistics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/classic-stats/conf_int.html">Confidence intervals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/classic-stats/pca.html">Principal component analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/classic-stats/bootstrap.html">Bootstrapping</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../statistics/hypo-testing/hypo_testing.html">27. Hypothesis Testing</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/hypo-testing/1_samp_t_test.html">One sample <span class="math notranslate nohighlight">\(t\)</span>-test</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../statistics/sampling/sampling_methods.html">28. Sampling Methods</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/sampling/inv_trans_sampling.html">Inverse transform sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/sampling/rejection_sampling.html">Rejection sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/sampling/mcmc.html">Markov chain monte carlo</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../statistics/high-dim-stats/high_dim.html">29. High-Dimensional Statistics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/high-dim-stats/robust_pca.html">Robust principal component analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/high-dim-stats/compress_sense.html">Compressed sensing</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../statistics/bayesian-statistics/bayesian_statistics.html">30. Bayesian Statistics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/bayesian-statistics/cred_int.html">Credible interval</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/bayesian-statistics/hierarchical_models.html">Hierarchical models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../statistics/bayesian-statistics/missing_data.html">Missing data</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Back Matter</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../backmatter/bibliography.html">31. Bibliography</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/amanuelanteneh/aman-notes" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/amanuelanteneh/aman-notes/issues/new?title=Issue%20on%20page%20%2Fcomputerscience/algorithms/dynamic_prog.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/computerscience/algorithms/dynamic_prog.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Dynamic programming</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bottom-up-versus-top-down-approaches">Bottom-up versus top-down approaches</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#n-th-fibonacci-number"><span class="math notranslate nohighlight">\(n\)</span>-th Fibonacci number</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rod-cutting">Rod cutting</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#top-down-approach">Top-down approach</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mathematical-reasoning-for-solution">Mathematical reasoning for solution</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bottom-up-approach">Bottom-up approach</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#longest-increasing-subsequence">Longest increasing subsequence</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#potential-solution">Potential solution</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#key-insight">Key Insight</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-analysis">Complexity analysis</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#longest-common-subsequence">Longest common subsequence</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#determining-subproblem-structure">Determining subproblem structure</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#knapsack">Knapsack</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#no-repetition">No repetition</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#better-subproblem-definition">Better subproblem definition</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity">Complexity</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#with-repetition">With repetition</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#chain-matrix-multiplication">Chain matrix multiplication</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">Bottom-up approach</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#characterize-the-structure-of-an-optimal-solution-parenthesization">1. Characterize the structure of an optimal solution (parenthesization)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#recursively-define-the-value-of-an-optimal-solution">2. Recursively define the value of an optimal solution</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#shortest-paths">Shortest paths</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#practice-problems">Practice problems</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#maximal-contiguous-subsequence">6.1 Maximal Contiguous Subsequence</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hotel-stops">6.2 Hotel Stops</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#yuckdonalds">6.3 Yuckdonald’s</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dictionary-lookup">6.4 Dictionary lookup</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#trinary-multiplication">6.6 Trinary multiplication</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#longest-palindromic-subsequence">6.7 Longest palindromic subsequence</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#longest-common-substring">6.8 Longest common substring</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">6.11 Longest common subsequence</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#making-change">6.17 Making change</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#making-change-2">6.18 Making change 2</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#making-change-3">6.19 Making change 3</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#optimal-binary-search-trees">6.20 Optimal binary search trees</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sequence-alignment">6.26 Sequence alignment</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tabulate</span> <span class="kn">import</span> <span class="n">tabulate</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="c1"># for reproducibility</span>
</pre></div>
</div>
</div>
</details>
</div>
<section class="tex2jax_ignore mathjax_ignore" id="dynamic-programming">
<h1>Dynamic programming<a class="headerlink" href="#dynamic-programming" title="Link to this heading">#</a></h1>
<p>Dynamic programming is similar to the divide and conquer approach except that the subproblems overlap i.e. the subproblems share the same sub-subproblems. This method of solving problems typically is used in optimization problems, particularly optimal control problems, and was originally developed by Richard E. Bellman who is also famous for developing the closely related Bellman equation which is at the core of reinforcement learning <span id="id1">[<a class="reference internal" href="../../backmatter/bibliography.html#id21" title="Richard S Sutton and Andrew G Barto. Reinforcement learning: An introduction. MIT press, 2018.">Sutton and Barto, 2018</a>]</span>.</p>
<p>The key strategy is to store the solutions, in a hashtable for example, to the subproblems and then reuse the solution later if the same subproblem is encountered rather than recomputing the solution <span id="id2">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span>. Computing the <span class="math notranslate nohighlight">\(n\)</span>-th Fibonacci number is a common example problem that illustrates this. This is a crucial distinction between dynamic programming versus divide and conquer: in the former the subproblems may overlap or appear multiple times and we can exploit this redundancy by storing solutions to these subproblems to reuse when we encounter them later on in the process of solving the problem.</p>
<section id="bottom-up-versus-top-down-approaches">
<h2>Bottom-up versus top-down approaches<a class="headerlink" href="#bottom-up-versus-top-down-approaches" title="Link to this heading">#</a></h2>
<p>There are two approaches to solving dynamic programming problems: bottom-up and top-down <span id="id3">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span>. The top-down approach involves writing the algorithm recursively and utilizing <em>memoization</em> (which we go over later).  The bottom-up approach does not utilize recursion, and thus usually has better constant factors for complexity since we avoid the time and space overhead of multiple function calls, but instead solves the “smallest” subproblems first and uses those solutions to construct solutions to the next largest subproblems until the overall problem is solved.</p>
</section>
<section id="n-th-fibonacci-number">
<h2><span class="math notranslate nohighlight">\(n\)</span>-th Fibonacci number<a class="headerlink" href="#n-th-fibonacci-number" title="Link to this heading">#</a></h2>
<p>Here we’ll go over a simple example that demonstrates the power of dynamic programming, along with the difference in the two approaches, by computing the <span class="math notranslate nohighlight">\(n\)</span>-th Fibonacci number.</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Fibonacci number <span class="math notranslate nohighlight">\(F_n\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[
F_n = F_{n-1} + F_{n-2}
\]</div>
<p>where the <span class="math notranslate nohighlight">\(0\)</span>-th and <span class="math notranslate nohighlight">\(1\)</span>-st Fibonacci number are defined as <span class="math notranslate nohighlight">\(F_0=0\)</span> and <span class="math notranslate nohighlight">\(F_1=1\)</span> respectively. This has a clear, albeit naive, recursive implementation in code shown below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">n: the n-th Fibonacci number desired</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">def</span> <span class="nf">naive_fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
       <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
       <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
       <span class="n">Fn</span> <span class="o">=</span> <span class="n">naive_fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">naive_fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
       <span class="k">return</span> <span class="n">Fn</span>
   
<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">35</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">-th Fibonacci number is: </span><span class="si">{</span><span class="n">naive_fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Took </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>35-th Fibonacci number is: 9227465
Took 2.426 seconds
</pre></div>
</div>
</div>
</div>
<p>The implementation is naive because of the two recursive calls <code class="docutils literal notranslate"><span class="pre">naive_fibonacci(n</span> <span class="pre">-</span> <span class="pre">1)</span></code> and <code class="docutils literal notranslate"><span class="pre">naive_fibonacci(n</span> <span class="pre">-</span> <span class="pre">2)</span></code>. For example when <span class="math notranslate nohighlight">\(n=10\)</span> the first recursive call computes <span class="math notranslate nohighlight">\(F_9\)</span> and the second recursive call computes <span class="math notranslate nohighlight">\(F_8\)</span>. However to compute <span class="math notranslate nohighlight">\(F_9\)</span> the first recursive call is going to need to compute <span class="math notranslate nohighlight">\(F_8\)</span> but wait, <span class="math notranslate nohighlight">\(F_8\)</span> is already being computed by the <em>second</em> recursive call. This means we’re doing double the work and it only gets worse as <span class="math notranslate nohighlight">\(n\)</span> increases! We can get around this by <em>storing</em> the solutions to smaller Fibonacci problems in a hashtable/dict that we have already computed and when we need to compute them again we can simply look up the solution in the table. This is called <em><strong>memoization</strong></em> and is the key distinction between dynamic programming versus divide &amp; conquer approaches.</p>
<div class="dropdown admonition note">
<p class="admonition-title">Note</p>
<p>Note this isn’t a typo; it’s actually spelled <em>memoization</em> and refers to the idea of memos since we store the value and look back at it later <span id="id4">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span>. In my opinion <em>memorization</em> would also work just as well since we are memorization the solution to a problem.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fast_fibonacci_top_down</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">memo</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
       <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
       <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
       <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
       <span class="n">Fn</span> <span class="o">=</span> <span class="n">fast_fibonacci_top_down</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span> <span class="o">+</span> <span class="n">fast_fibonacci_top_down</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
       <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fn</span>
       <span class="k">return</span> <span class="n">Fn</span>

<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># for memoization </span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">-th Fibonacci number is: </span><span class="si">{</span><span class="n">fast_fibonacci_top_down</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">memo</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Took </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>35-th Fibonacci number is: 9227465
Took 0.000 seconds
</pre></div>
</div>
</div>
</div>
<p>We can also solve this without memoization using the bottom-up approach. In this case we simply solve the smallest subproblems, which in this case is finding the value of <span class="math notranslate nohighlight">\(F_2\)</span>, first and then use that solution along with the solution to the previous “smallest” subproblem, i.e. finding the value of <span class="math notranslate nohighlight">\(F_1\)</span>, to find the solution of the next largest subproblem i.e. finding the value of <span class="math notranslate nohighlight">\(F_3\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fast_fibonacci_bottom_up</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">Fn_2</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># F_{n-2}</span>
    <span class="n">Fn_1</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># F_{n-1}</span>
    <span class="n">Fn</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># F_n</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">Fn</span> <span class="o">=</span> <span class="n">Fn_1</span>  <span class="o">+</span> <span class="n">Fn_2</span>
        <span class="n">Fn_2</span> <span class="o">=</span> <span class="n">Fn_1</span> 
        <span class="n">Fn_1</span> <span class="o">=</span> <span class="n">Fn</span>
    
    <span class="k">return</span> <span class="n">Fn</span>

<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">-th Fibonacci number is: </span><span class="si">{</span><span class="n">fast_fibonacci_bottom_up</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Took </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>35-th Fibonacci number is: 9227465
Took 0.000 seconds
</pre></div>
</div>
</div>
</div>
<p>This method has time complexity <span class="math notranslate nohighlight">\(O(n)\)</span> but a space complexity of <span class="math notranslate nohighlight">\(O(1)\)</span> since we do not utilize an array to store all <span class="math notranslate nohighlight">\(n\)</span> solutions to smaller subproblems.</p>
</section>
<section id="rod-cutting">
<h2>Rod cutting<a class="headerlink" href="#rod-cutting" title="Link to this heading">#</a></h2>
<p>Let’s go over the first example of an application of dynamic programming from <span id="id5">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span>.</p>
<p>Suppose we have a rod of length <span class="math notranslate nohighlight">\(n \in \mathbb{Z^+}\)</span> and we can sell the rod for a price <span class="math notranslate nohighlight">\(p_n\)</span> which is the cash we get for selling a rod of length <span class="math notranslate nohighlight">\(n\)</span>. We can <em>also</em> cut the rod into <span class="math notranslate nohighlight">\(k\)</span> parts of integer length <span class="math notranslate nohighlight">\(c_i\)</span> such that (obviously)</p>
<div class="math notranslate nohighlight">
\[
\begin{align*}
n = c_1 + c_2 + \dots + c_k \quad \text{where $c_i \in \mathbb{Z^+}$}
\end{align*}
\]</div>
<p>and sell each part for the revenue <span class="math notranslate nohighlight">\(r_n = p_{c_1} + p_{c_2} + \dots + p_{c_k}\)</span> where again <span class="math notranslate nohighlight">\(p_{c_i}\)</span> is the cash we get for selling a rod of integer length <span class="math notranslate nohighlight">\(c_i\)</span>. The caveat here is that there maybe certain ways to cut the rod such that we actually get more revenue by selling the individually cut pieces instead of selling the uncut rod.
Clearly this depends on the pricing for each length of rod.  Can we devise an algorithm that, given the length <span class="math notranslate nohighlight">\(n\)</span> of the rod along with the prices <span class="math notranslate nohighlight">\(p_1, p_2,\dots, p_n\)</span> for selling a rod of length <span class="math notranslate nohighlight">\(1, 2, \dots, n\)</span> respectively, finds an (as there could be more than one I think) optimal way of cutting the rod such that we net the highest revenue?</p>
<section id="top-down-approach">
<h3>Top-down approach<a class="headerlink" href="#top-down-approach" title="Link to this heading">#</a></h3>
<p><span id="id6">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span> uses a top-down approach so I will go over that first.</p>
<section id="mathematical-reasoning-for-solution">
<h4>Mathematical reasoning for solution<a class="headerlink" href="#mathematical-reasoning-for-solution" title="Link to this heading">#</a></h4>
<p>Suppose that an optimal way of cutting the rod (optimal integer decomposition of <span class="math notranslate nohighlight">\(n\)</span>) cuts the rod into <span class="math notranslate nohighlight">\(k\)</span> pieces for some integer <span class="math notranslate nohighlight">\(1 \leq k \leq n\)</span>. We denote this optimal decomposition as</p>
<div class="math notranslate nohighlight">
\[
n_{\text{opt}} = c_1 + c_2 + \dots + c_k
\]</div>
<p>where <span class="math notranslate nohighlight">\(c_i\)</span> is the length of the <span class="math notranslate nohighlight">\(i\)</span>-th segment of the rod. The corresponding optimal revenue is thus</p>
<div class="math notranslate nohighlight">
\[
r_{n_{\text{opt}}} = p_{c_1} + p_{c_2} + \dots + p_{c_k}.
\]</div>
<p>In general we can write the optimal revenue <span class="math notranslate nohighlight">\(r_{n_{\text{opt}}}\)</span> in terms of optimal revenues for rods of shorter length</p>
<div class="math notranslate nohighlight">
\[
r_{n_{\text{opt}}} = \max\left(p_n, r_{1_{\text{opt}}} + r_{(n-1)_{\text{opt}}}, r_{2_{\text{opt}}} + r_{(n-2)_{\text{opt}}}, \dots, r_{(n-1)_{\text{opt}}} + r_{1_{\text{opt}}} \right)
\]</div>
<p>where <span class="math notranslate nohighlight">\(p_n\)</span> is the revenue gained from selling the uncut rod of length <span class="math notranslate nohighlight">\(n\)</span>. The other <span class="math notranslate nohighlight">\(n-1\)</span> arguments to <span class="math notranslate nohighlight">\(\max\)</span> correspond to the revenue gained from cutting the rod into two pieces of size <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(n-i\)</span> respectively <span class="math notranslate nohighlight">\(\forall i \in \{1,2,\dots,n-1\}\)</span> and then optimally cutting up the two resulting pieces of the rod further.</p>
<p>If you think about it it makes sense that the optimal solution for this problem can be achieved by combining optimal solutions of smaller problems. Specifically, when you start with the uncut rod the two options are either</p>
<ol class="arabic simple">
<li><p>the uncut rod is already optimal to sell</p></li>
</ol>
<p><span class="math notranslate nohighlight">\(\qquad \qquad \qquad \Large{\textbf{or}}\)</span></p>
<ol class="arabic simple" start="2">
<li><p>there is a way to cut it to get more revenue in which case you know you have to cut it into <em><strong>at least</strong></em> two pieces.</p></li>
</ol>
<p>If the second option is chosen then after that point you have two new rods which you need to find the optimal cutting/decomposition of and you simply repeat the previous step again for each rod. The problem here is you need to cut the rod into two pieces in <em><strong>every</strong></em> possible way since you don’t know ahead of time which way of cutting the rod into two pieces (i.e. which value of <span class="math notranslate nohighlight">\(i\)</span>) is optimal hence all the <span class="math notranslate nohighlight">\(n-1\)</span> arguments to <span class="math notranslate nohighlight">\(\max\)</span>. Doing this naively would result in a time complexity of <span class="math notranslate nohighlight">\(O(2^n)\)</span> but with dynamic programming we can reduce this time <strong>exponentially</strong>.</p>
<div class="dropdown admonition note">
<p class="admonition-title">Note</p>
<p>Where do we get the <span class="math notranslate nohighlight">\(O(2^n)\)</span> complexity from? It comes from the number of ways we can cut up the rod. It helps if we think of this in terms of integer compositions. For an integer <span class="math notranslate nohighlight">\(n\)</span> a composition is a way of writing <span class="math notranslate nohighlight">\(n\)</span> as a sum of <em>positive</em> integers i.e. integers greater than <span class="math notranslate nohighlight">\(0\)</span>. For example for  the number 3 the  possible compositions are <span class="math notranslate nohighlight">\(1+1+1\)</span>, <span class="math notranslate nohighlight">\(2+1\)</span>, <span class="math notranslate nohighlight">\(1+2\)</span> and <span class="math notranslate nohighlight">\(3\)</span>. It is clear that the number of compositions of the integer <span class="math notranslate nohighlight">\(n\)</span> are exactly equal to the number of ways we can cut up a rod of length <span class="math notranslate nohighlight">\(n\)</span>. So how can we derive the number of compositions of an integer <span class="math notranslate nohighlight">\(n\)</span>? From elementary combinatorics we know that the number of compositions of <span class="math notranslate nohighlight">\(n\)</span> into exactly <span class="math notranslate nohighlight">\(j\)</span> parts is <span class="math notranslate nohighlight">\({n-1 \choose j-1}\)</span>. To get the total number of compositions we can simply sum all values of <span class="math notranslate nohighlight">\(j\)</span> from <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(n\)</span> and using the binomial theorem.</p>
<div class="amsmath math notranslate nohighlight" id="equation-d59ffedd-e9b4-4fa8-91a4-9983407d9e82">
<span class="eqno">(19.1)<a class="headerlink" href="#equation-d59ffedd-e9b4-4fa8-91a4-9983407d9e82" title="Permalink to this equation">#</a></span>\[\begin{align}
2^{n-1} &amp;= (1+1)^{n-1} \\
&amp;= \sum^{n-1}_{k=0}{n-1 \choose k} 1^{n-1-k}1^{k} \\
&amp;= \sum^{n-1}_{k=0}{n-1 \choose k} \\
&amp;\text{Re-index the summation with $k=j-1$ so lower bound becomes $j-1=0\rightarrow j=1$ and upper bound becomes $j-1=n-1\rightarrow j=n$} \\
&amp;=\sum^{n}_{j=1}{n-1 \choose j-1} \qquad \blacksquare
\end{align}\]</div>
</div>
<p>We can simplify the general equation for <span class="math notranslate nohighlight">\(r_{n_{\text{opt}}}\)</span> a bit more by noticing that in the argument to <span class="math notranslate nohighlight">\(\max\)</span> we are actually double counting cases i.g. we have both <span class="math notranslate nohighlight">\(r_{1_{\text{opt}}} + r_{(n-1)_{\text{opt}}}\)</span> and <span class="math notranslate nohighlight">\(r_{(n-1)_{\text{opt}}} + r_{1_{\text{opt}}}\)</span> being counted. Instead we can just consider each case without it’s reverse, since it doesn’t matter which of the two new rods we cut up in a certain way (addition is commutative), and we can get the more simple formula</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
r_{n_{\text{opt}}} &amp;= \max\left(p_n, r_{1_{\text{opt}}} + r_{(n-1)_{\text{opt}}}, r_{2_{\text{opt}}} + r_{(n-2)_{\text{opt}}}, \dots, r_{(n-\frac{n}{2})_{\text{opt}}} + r_{{\frac{n}{2}}_{\text{opt}}} \right) \\
&amp;= \max\left(p_{i} + r_{(n-i)_{\text{opt}}}\right) \quad \text{$\forall i \in \{1,2,\dots,n\}$} 
\end{align*}
\end{split}\]</div>
<p>When a problem can be solved like this by breaking it onto smaller parts, solving those smaller parts independently, and then combining those solutions to those smaller parts we say the problem exhibits <strong>optimal sub-structure</strong>.</p>
<p>Below is some recursive code that solves this problem</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">p: A dict where the keys are the length of the rod and the value is the revenue gained from selling a rod of that length</span>

<span class="sd">n: The (integer) length of the rod</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">def</span> <span class="nf">naive_rod_cutting</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># if rod is length 0 terminate and get 0 revenue (recursive termination condition)</span>
       <span class="k">return</span> <span class="mi">0</span>
    
    <span class="n">max_rev</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span> <span class="c1"># initially set revenue to lowest possible number</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># loop over each possible first cut into two parts</span>
        <span class="n">max_rev</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_rev</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">naive_rod_cutting</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">))</span> 
    
    <span class="k">return</span> <span class="n">max_rev</span>

<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">24</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">{</span>  <span class="n">i</span><span class="p">:[</span><span class="n">i</span><span class="o">*</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="p">}</span> <span class="c1"># generate some random test case, make each item a list b/c tabulate requires it</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Test case table of rod lengths 1 to </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> (top row) and corresponding revenues for selling (bottom row):&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tabulate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="s1">&#39;keys&#39;</span><span class="p">,</span> <span class="n">tablefmt</span><span class="o">=</span><span class="s1">&#39;fancy_grid&#39;</span><span class="p">))</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">{</span>  <span class="n">k</span><span class="p">:</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>  <span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Max revenue for rod of length </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> is:&quot;</span><span class="p">,</span> <span class="n">naive_rod_cutting</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Took </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Test case table of rod lengths 1 to 24 (top row) and corresponding revenues for selling (bottom row):
╒═════╤═════╤═════╤═════╤═════╤═════╤═════╤═════╤═════╤══════╤══════╤══════╤══════╤══════╤══════╤══════╤══════╤══════╤══════╤══════╤══════╤══════╤══════╤══════╕
│   1 │   2 │   3 │   4 │   5 │   6 │   7 │   8 │   9 │   10 │   11 │   12 │   13 │   14 │   15 │   16 │   17 │   18 │   19 │   20 │   21 │   22 │   23 │   24 │
╞═════╪═════╪═════╪═════╪═════╪═════╪═════╪═════╪═════╪══════╪══════╪══════╪══════╪══════╪══════╪══════╪══════╪══════╪══════╪══════╪══════╪══════╪══════╪══════╡
│   1 │   2 │   9 │  12 │  10 │  12 │  14 │  16 │  81 │   20 │  110 │   84 │   13 │   14 │   30 │  112 │  136 │  306 │   19 │  360 │  147 │  462 │  529 │  432 │
╘═════╧═════╧═════╧═════╧═════╧═════╧═════╧═════╧═════╧══════╧══════╧══════╧══════╧══════╧══════╧══════╧══════╧══════╧══════╧══════╧══════╧══════╧══════╧══════╛
Max revenue for rod of length 24 is: 530
Took 4.822 seconds
</pre></div>
</div>
</div>
</div>
<p>Now this code works but there is a big issue. For large values of <span class="math notranslate nohighlight">\(n\)</span> this code will take a vey long time to run. This makes sense if we think of this in terms of a recursion tree. Below we have an example from <span id="id7">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span> of the recursion tree for <code class="docutils literal notranslate"><span class="pre">naive_rod_cutting</span></code> for <span class="math notranslate nohighlight">\(n=4\)</span>. So we have the initial call to the function with <span class="math notranslate nohighlight">\(n=4\)</span> now what happens once we get to the <code class="docutils literal notranslate"><span class="pre">for</span></code> loop? The function is called recursively at <em>each</em> iteration of the loop. During the first iteration we call the function recursively with <span class="math notranslate nohighlight">\(n=3\)</span> which can be seen in the leftmost branch of the tree connected to the root. But wait this recursive call <em>will also loop over all integers that are less than <span class="math notranslate nohighlight">\(n=3\)</span></em> and recursively call itself at each iteration again and so on for those recursive calls until the base case of <span class="math notranslate nohighlight">\(n=0\)</span> is reached. More interestingly from the recursion tree we can see that we are calling the function with the same value of <span class="math notranslate nohighlight">\(n\)</span> multiple times. For example we call the function with <span class="math notranslate nohighlight">\(n=2\)</span> two times and with <span class="math notranslate nohighlight">\(n=1\)</span> four times. So not only are we exhaustively looking at each possible way of cutting the rod we are also recomputing the solutions for different values of <span class="math notranslate nohighlight">\(n\)</span> over and over again.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">display</span><span class="p">(</span><span class="n">Image</span><span class="p">(</span><span class="s2">&quot;img/rod_cut_recursion_tree.png&quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">))</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<a class="reference internal image-reference" href="../../_images/b4dc3e59649862d82339db6c197137984dcd59d8556b80f66aba9b56f20193be.png"><img alt="../../_images/b4dc3e59649862d82339db6c197137984dcd59d8556b80f66aba9b56f20193be.png" src="../../_images/b4dc3e59649862d82339db6c197137984dcd59d8556b80f66aba9b56f20193be.png" style="width: 600px;" /></a>
</div>
</div>
<p>Now instead of solving the same subproblem over and we can instead <em>store</em> the solution to a subproblem, in this case the optimal revenue one can get for a rod of length <span class="math notranslate nohighlight">\(n' &lt; n\)</span>, in a hashtable and then when we come across that subproblem again we can retrieve this solution from the hashtable instead of recomputing a problem we’ve already solved.</p>
<p>A more efficient version of the <code class="docutils literal notranslate"><span class="pre">naive_rod_cutting</span></code> algorithm, which utilizes memoization, is given below. This algorithm brings the time complexity from <span class="math notranslate nohighlight">\(O(2^n)\)</span> to <span class="math notranslate nohighlight">\(O(n^2)\)</span> so an exponential speedup! Although note that this comes with the cost of increasing the space complexity from <span class="math notranslate nohighlight">\(O(1)\)</span> to <span class="math notranslate nohighlight">\(O(n)\)</span> since we are storing a solution for each of the values of rod length that are <span class="math notranslate nohighlight">\(&lt; n\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fast_rod_cutting_top_down</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
   <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">memo</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> <span class="c1"># check memo to see if we&#39;ve already solved this problem for this value of n</span>
      <span class="n">max_rev</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
      <span class="k">return</span> <span class="n">max_rev</span>

   <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># if rod is length 0 terminate and get 0 revenue (recursive termination condition)</span>
      <span class="k">return</span> <span class="mi">0</span>
    
   <span class="n">max_rev</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span> <span class="c1"># initially set revenue to lowest possible number</span>
    
   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># loop over each possible first cut into two parts</span>
      <span class="n">max_rev</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_rev</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">fast_rod_cutting_top_down</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">memo</span><span class="p">))</span>
   
   <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_rev</span> <span class="c1"># save max revenue found for this value of n</span>
    
   <span class="k">return</span> <span class="n">max_rev</span>

<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># for memoization </span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Max revenue for rod of length </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> is:&quot;</span><span class="p">,</span> <span class="n">fast_rod_cutting_top_down</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">memo</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Took </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Max revenue for rod of length 24 is: 530
Took 0.000 seconds
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="bottom-up-approach">
<h3>Bottom-up approach<a class="headerlink" href="#bottom-up-approach" title="Link to this heading">#</a></h3>
<p>For the bottom-up approach we can state the recurrence relation and base case as</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\text{Base cases:} \\ &amp;\quad r_0^{opt} = 0, \quad r_1^{opt} = p_1 \\ \\
\text{Recurrence:}\\ \quad r_i^{opt} &amp;= \max\left\{ \max_j\left\{ r_j^{opt} + p_{i-j} \right\}, \quad p_i \right\} \quad \text{where} \quad 1 \leq i \leq n, \text{ } 1 \leq j &lt; i \\
 &amp;= \max\left\{ \max_j\left\{ r_j^{opt} + r_{i-j}^{opt} \right\}, \quad p_i \right\} \quad \text{where} \quad 1 \leq i \leq n, \text{ } 1 \leq j &lt; i \\
\end{align*}
\end{split}\]</div>
<p>This first recurrence can be read as saying: For a rod of length <span class="math notranslate nohighlight">\(i\)</span> the maximum revenue attainable will be either the revenue from selling the whole uncut rod <em><strong>or</strong></em> the revenue from cutting it into a rod of length <span class="math notranslate nohighlight">\(i-j\)</span> and selling that and cutting the other part of the rod, which is of length <span class="math notranslate nohighlight">\(j\)</span>, into the optimal set of pieces for a rod of length <span class="math notranslate nohighlight">\(j\)</span> and selling those. Since <span class="math notranslate nohighlight">\(j\)</span> is smaller than <span class="math notranslate nohighlight">\(i\)</span> this is a smaller subproblem we have solved before and we can therefore just use the solution to that problem to solve this problem. See how much easier this was to understand than top-down?</p>
<p>The second line of the recurrence which will also give us the correct answer can be read as saying: For a rod of length <span class="math notranslate nohighlight">\(i\)</span> the maximum revenue attainable will be either the revenue from selling the whole uncut rod <em><strong>or</strong></em> cutting the rod into two pieces, one of length <span class="math notranslate nohighlight">\(j\)</span> and the other of length <span class="math notranslate nohighlight">\(i-j\)</span> and cutting each of those pieces into the optimal set of pieces for a rod of length <span class="math notranslate nohighlight">\(j\)</span> and <span class="math notranslate nohighlight">\(i-j\)</span> respectively.</p>
<p>These two ways of writing the recurrences was something we covered above from <span id="id8">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span> but I didn’t fully understand how they were equivalent until solving this problem in the bottom up way and thinking about it. I think its fairly clear why the second line would be correct since we are using the optimal solutions from previous problems for <em>both</em> cuts of the rod. However, I was confused as to how cutting the rod into two pieces and only cutting <em>one</em> of those pieces into the optimal set of pieces and selling the other part whole could yield the same result until I used an insight I got from the longest increasing subsequence problem we covered in lecture with Dr. Vigoda. That is: whatever the optimal way of cutting the rod is it <em>must</em> include selling one piece of the rod that is of length <span class="math notranslate nohighlight">\(j\)</span> with no further cuts. However, the remaining rod of length <span class="math notranslate nohighlight">\(i-j\)</span> <em>will</em> need to be cut into more (optimal) pieces so we just need to check each configuration of: sell rod of length <span class="math notranslate nohighlight">\(j\)</span> whole and cut up the remaining rod of length <span class="math notranslate nohighlight">\(i-j\)</span> into the optimal set of pieces and the one with maximal revenue will be our answer. Note that this recurrence works fine if we swap the rod that is sold whole to be of length <span class="math notranslate nohighlight">\(i-j\)</span> and then cut the rod of length <span class="math notranslate nohighlight">\(j\)</span> into more optimal pieces.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fast_rod_cutting_bottom_up</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="p">[</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">]</span> <span class="c1"># set baseline solutions to just be the revenue for selling the whole rod of length i</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="c1"># note the +1 in the p indices are due to fact that the keys of p start at 1 and not 0</span>
            <span class="k">if</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sol</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">]:</span>
               <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">sol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Max revenue for rod of length </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> is:&quot;</span><span class="p">,</span> <span class="n">fast_rod_cutting_bottom_up</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Took </span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Max revenue for rod of length 24 is: 530
Took 0.000 seconds
</pre></div>
</div>
</div>
</div>
<p>In my opinion the bottom up approach is much simpler to understand. For example, it is much clearer to see why the time complexity of this algorithm is <span class="math notranslate nohighlight">\(O(n^2)\)</span> then it is for the top-down algorithm.</p>
</section>
</section>
<section id="longest-increasing-subsequence">
<h2>Longest increasing subsequence<a class="headerlink" href="#longest-increasing-subsequence" title="Link to this heading">#</a></h2>
<p>This was the first problem covered in lecture. The problem can be state as follows. Given a sequence of numbers</p>
<div class="math notranslate nohighlight">
\[
L_n=a_1,a_2,...a_n
\]</div>
<p>how can we find the length <span class="math notranslate nohighlight">\(L_n^s\)</span> of the longest increasing subsequence (LIS)? A subsequence is any subset of this sequence that preservers the relative ordering of the elements in the original sequence. For example <span class="math notranslate nohighlight">\(a_1,a_2,a_3\)</span> is a subsequence as is <span class="math notranslate nohighlight">\(a_3, a_4, a_7\)</span> but not <span class="math notranslate nohighlight">\(a_3, a_2, a_5\)</span>. An increasing subsequence is a subsequence where each element <span class="math notranslate nohighlight">\(a_i\)</span> is strictly greater than the previous term in the sequence so</p>
<div class="math notranslate nohighlight">
\[
a_i &lt; a_{i+1} &lt; ... &lt; a_j.
\]</div>
<section id="potential-solution">
<h3>Potential solution<a class="headerlink" href="#potential-solution" title="Link to this heading">#</a></h3>
<p>Thinking of this in terms of dynamic programming we may think to take the bottom-up approach to find the length of the LIS. That is we first find the length of the LIS for the smallest subproblem</p>
<div class="math notranslate nohighlight">
\[
L_1=a_1
\]</div>
<p>and then use that solution to compute the length of the LIS for the next largest subproblem</p>
<div class="math notranslate nohighlight">
\[
L_2=a_1,a_2
\]</div>
<p>and so on until we compute the length of the LIS for the full sequence <span class="math notranslate nohighlight">\(L_n\)</span>. Note that for the case of <span class="math notranslate nohighlight">\(L_1\)</span> the solution is trivial: the LIS for a sequence with one element is always just that one element which has length <span class="math notranslate nohighlight">\(L_1^s=1\)</span>.</p>
<p>Let’s use the specific example from lecture</p>
<div class="math notranslate nohighlight">
\[
L_{n=12} = 5,7,4,-3,9,1,10,4,5,8,9,3.
\]</div>
<p>So the smallest subproblem is <span class="math notranslate nohighlight">\(L_1=5\)</span> for which the LIS is <span class="math notranslate nohighlight">\(5\)</span> and the solution is thus <span class="math notranslate nohighlight">\(L_1^s=1\)</span>. The next smallest subproblem is <span class="math notranslate nohighlight">\(L_2=5,7\)</span>. Using the previous solution we can just check to see if the newly added element, <span class="math notranslate nohighlight">\(7\)</span>, is strictly greater than the last element in the LIS for the previous subproblem. If it is then we append that element to the end of the LIS for the previous subproblem and add <span class="math notranslate nohighlight">\(1\)</span> to the solution of the previous problem. If it is not strictly greater then we simply use the solution from the previous subproblem as the solution to this subproblem. For the case of <span class="math notranslate nohighlight">\(L_2\)</span>, since <span class="math notranslate nohighlight">\(7&gt;5\)</span>, the LIS is <span class="math notranslate nohighlight">\(5,7\)</span> and thus <span class="math notranslate nohighlight">\(L_2^s=2\)</span>. The next smallest subproblem is <span class="math notranslate nohighlight">\(L_3=5,7,4\)</span> and we simply do the same check as we did for the previous one. Since <span class="math notranslate nohighlight">\(4 \not &gt; 5\)</span> the solution to this subproblem is the same as the solution to <span class="math notranslate nohighlight">\(L_2\)</span> i.e the LIS is <span class="math notranslate nohighlight">\(5,7\)</span> and <span class="math notranslate nohighlight">\(L_3^s=2\)</span>. For <span class="math notranslate nohighlight">\(L_4=5,7,4,-3\)</span> we get the same result.</p>
<p>Suppose we continue this up until the 10th smallest subproblem</p>
<div class="math notranslate nohighlight">
\[
L_{10}=5,7,4,-3,9,1,10,4,5,8.
\]</div>
<p>If we have been using the same procedure as before we will have found the solution to the previous subproblem</p>
<div class="math notranslate nohighlight">
\[
L_9=5,7,4,-3,9,1,10,4,5
\]</div>
<p>to be <span class="math notranslate nohighlight">\(L_9^s=4\)</span> with the LIS being <span class="math notranslate nohighlight">\(5,7,9,10\)</span>. If we use this solution to construct our solution to <span class="math notranslate nohighlight">\(L_{10}\)</span> using the same check as before we will deduce that the LIS is still <span class="math notranslate nohighlight">\(5,7,9,10\)</span> and <span class="math notranslate nohighlight">\(L_{10}^s=4\)</span>. But this is <em><strong>wrong</strong></em>. There is actually a longer LIS, i.e. <span class="math notranslate nohighlight">\(-3,1,4,5,8\)</span>, which has length <span class="math notranslate nohighlight">\(5\)</span>.</p>
<p>Clearly our approach is not optimal. We are either specifying the subproblems incorrectly or incorrectly combining their solutions to create solutions for larger subproblems. Let’s think about how this went wrong. We now know the LIS for <span class="math notranslate nohighlight">\(L_{10}\)</span> is</p>
<div class="math notranslate nohighlight">
\[
-3,1,4,5,8.
\]</div>
<p>For our initial procedure to have worked it would have had to find that the LIS for the previous subproblem <span class="math notranslate nohighlight">\(L_9\)</span> was</p>
<div class="math notranslate nohighlight">
\[
-3,1,4,5.
\]</div>
<p>But this is not what our procedure finds the LIS to be. Our procedure finds that</p>
<div class="math notranslate nohighlight">
\[
5,7,9,10
\]</div>
<p>is the LIS for <span class="math notranslate nohighlight">\(L_9\)</span>. Notice that both of these LIS are of length 4 but the first is more optimal for solving subproblems down the road. This is because the first subsequence has a final element, <span class="math notranslate nohighlight">\(5\)</span>, which is smaller than the final element of the second subsequence, <span class="math notranslate nohighlight">\(10\)</span>, which allows for more options to append to the end of the subsequence when considering the next subproblem since there are more numbers that are larger than <span class="math notranslate nohighlight">\(5\)</span> then there are numbers that are larger than <span class="math notranslate nohighlight">\(10\)</span>.</p>
<p>We should also note that our procedure would have found the LIS for <span class="math notranslate nohighlight">\(L_8\)</span> to also be <span class="math notranslate nohighlight">\(5,7,9,10\)</span> but in fact to get the true LIS for <span class="math notranslate nohighlight">\(L_{10}\)</span> we would have needed the LIS for <span class="math notranslate nohighlight">\(L_8\)</span> to be <span class="math notranslate nohighlight">\(-3,1,4\)</span> which is <em>shorter</em> than the LIS found by our procedure and is thus not the true LIS for <span class="math notranslate nohighlight">\(L_8\)</span>. So what do we do?</p>
</section>
<section id="key-insight">
<h3>Key Insight<a class="headerlink" href="#key-insight" title="Link to this heading">#</a></h3>
<p>The crucial insight here is that the LIS for the <span class="math notranslate nohighlight">\(i\)</span>-th smallest subproblem <em><strong>is not necessarily</strong></em> going to be built from the LIS of the previous, i.e. <span class="math notranslate nohighlight">\((i-1)\)</span>-th smallest, subproblem (as we erroneously assumed in our original procedure). It may in fact need to be built from the LIS for the <span class="math notranslate nohighlight">\((i-2)\)</span>-th smallest subproblem or the <span class="math notranslate nohighlight">\((i-3)\)</span>-th smallest or even smaller problems. To put it another way we can say that the solution to the <span class="math notranslate nohighlight">\(i\)</span>-th smallest problem will be one of two options:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(a_i\)</span> will be smaller than or equal to all of the previous <span class="math notranslate nohighlight">\(i-1\)</span> elements in <span class="math notranslate nohighlight">\(L_i\)</span> and thus the LIS is just <span class="math notranslate nohighlight">\(a_i\)</span> and <span class="math notranslate nohighlight">\(L_i^s=1\)</span>.</p></li>
</ol>
<p><span class="math notranslate nohighlight">\(\qquad \qquad \qquad \Large{\textbf{or}}\)</span></p>
<ol class="arabic simple" start="2">
<li><p>The LIS will be created by appending <span class="math notranslate nohighlight">\(a_i\)</span> to the end of <em><strong>one</strong></em> of the previous LISs for the previous <span class="math notranslate nohighlight">\(i-1\)</span> smaller subproblems <span class="math notranslate nohighlight">\(L_1,L_2,...L_{i-1}\)</span> since there must be some <span class="math notranslate nohighlight">\(a_j&lt;a_i\)</span> as the first case was not fulfilled. If we denote this previous subproblem as <span class="math notranslate nohighlight">\(L_j\)</span> we will have the length of the LIS for <span class="math notranslate nohighlight">\(L_i\)</span>, again denoted <span class="math notranslate nohighlight">\(L_i^s\)</span>, is equal to <span class="math notranslate nohighlight">\(L_i^s = L_j^s+1\)</span>. The plus one is needed since we are appending <span class="math notranslate nohighlight">\(a_i\)</span> to the end of the LIS for <span class="math notranslate nohighlight">\(L_j\)</span>. The important thing to note here is <em><strong>we do not know which value of <span class="math notranslate nohighlight">\(j\)</span> is the optimal one so we must loop through all of them</strong></em>. Note that this takes time linear in the size of the subproblem since we just have to loop over the solutions to <span class="math notranslate nohighlight">\(L_1,L_2,...L_{i-1}\)</span>. The only caveat with this case is that we have to make sure that we only append <span class="math notranslate nohighlight">\(a_i\)</span> to the LIS of <span class="math notranslate nohighlight">\(L_j\)</span> if doing so would result in an LIS that is longer than the current best LIS we have found from examining the previous smaller <span class="math notranslate nohighlight">\(j-1\)</span> subproblems. This caveat is accounted for by the second part of the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement in the below <code class="docutils literal notranslate"><span class="pre">Python</span></code> implementation of this algorithm.</p></li>
</ol>
<p>This is also equivalent to the subproblem definition that Professor Vigoda defines in the video lectures. He defines the subproblems as: <span class="math notranslate nohighlight">\(L_i^s\)</span> is the length of the longest increasing subsequence of the <span class="math notranslate nohighlight">\(i\)</span>-th subproblem <span class="math notranslate nohighlight">\(L_i=a_1,a_2,...,a_i\)</span> <em><strong>which includes <span class="math notranslate nohighlight">\(a_i\)</span></strong></em>. When I first heard this I was confused because it seemed like this was a very random condition to put on the subproblems. I mean what good does it do for us to require the LIS include the last element of the sequence? If you think about it however it makes sense: The LIS for the full problem must obviously end with <em>an</em> element in the sequence and if we find all LIS’s that end in every possible element in the sequence we simply need to look for the one with the longest length, and we have our answer.</p>
<p>A simple recurrence can give us the solution to our subproblems:</p>
<div class="math notranslate nohighlight">
\[
L_i^s = \max_j\left\{1 + L_j^s \bigg\vert a_i&gt;a_j, \quad 1 \right\} \quad \text{where} \quad 1\leq j \leq i-1.
\]</div>
<p>This recurrence can be read as saying: the length of the LIS of the sequence <span class="math notranslate nohighlight">\(a_1,..,a_i\)</span> is equal to the length of</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Bottom-up approach</span>
<span class="k">def</span> <span class="nf">length_of_LIS</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    
    <span class="c1"># start baseline for all LIS&#39;s. Set baseline to 1 since the shortest LIS will always have at least 1 element (the i-th element)</span>
    <span class="n">LIS_lens</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span> <span class="c1"># LIS_lens[i] = length of LIS for subproblem L_i</span>
    
    <span class="c1"># loop through all subproblems starting from the smallest one (L_i = L_1)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> 
        <span class="c1"># for each subproblem L_i examine all previous solutions to smaller subproblems L_j (meaning j&lt;i)</span>
        <span class="c1"># and see if the last element, a_i, of L_i can be appended to the end of any of them (a_i&gt;a_j)</span>
        <span class="c1"># if so also check if the resulting subsequence is longer than the current best LIS found for L_i</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="c1"># append a_i to the end of this previous subsequence only if a_i is greater than</span>
            <span class="c1"># the last element of the subsequence (a_j) AND if the new subsequence created would have length</span>
            <span class="c1"># greater than the current best subsequence found for the current subproblem (L_i)</span>
            <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">LIS_lens</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">LIS_lens</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> 
               <span class="n">LIS_lens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">LIS_lens</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># new LIS found for subproblem L_i</span>
    
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">LIS_lens</span><span class="p">)</span>

<span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Length of longest increasing subsequence for</span><span class="se">\n</span><span class="s2">L = </span><span class="si">{</span><span class="n">L</span><span class="si">}</span><span class="se">\n</span><span class="s2">is </span><span class="si">{</span><span class="n">length_of_LIS</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Length of longest increasing subsequence for
L = [5, 7, -3, 9, 1, 10, 4, 5, 8, 9, 3]
is 6.
</pre></div>
</div>
</div>
</div>
</section>
<section id="complexity-analysis">
<h3>Complexity analysis<a class="headerlink" href="#complexity-analysis" title="Link to this heading">#</a></h3>
<p>The time complexity of this algorithm is <span class="math notranslate nohighlight">\(O(n^2+n)=O(n^2)\)</span> due to the doubly nested for loops. The first loops over <span class="math notranslate nohighlight">\(n\)</span> items and the second loops over <span class="math notranslate nohighlight">\(i\)</span> items and <span class="math notranslate nohighlight">\(i=n\)</span> once we are at the last subproblem. The additive <span class="math notranslate nohighlight">\(n\)</span> in the big-<span class="math notranslate nohighlight">\(O\)</span> comes from the fact that we use a <code class="docutils literal notranslate"><span class="pre">max</span></code> at the end to return the longest LIS which takes linear time as it has to examine all elements. The space complexity is <span class="math notranslate nohighlight">\(O(n)\)</span> since we store the solutions to all <span class="math notranslate nohighlight">\(n\)</span> subproblems for later use.</p>
</section>
</section>
<section id="longest-common-subsequence">
<h2>Longest common subsequence<a class="headerlink" href="#longest-common-subsequence" title="Link to this heading">#</a></h2>
<p>The next problem we will look at is somewhat similar to the previous problem. Given two lists <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> of equal length <span class="math notranslate nohighlight">\(n\)</span> find the <em>length</em> of the longest <em>common</em> subsequence (LCS) between them. For example if</p>
<div class="math notranslate nohighlight">
\[
X_7=b,c,d,b,c,d,a \quad \text{ and } \quad Y_7=a,b,e,c,b,a,b
\]</div>
<p>the longest subsequence shared between the two is <span class="math notranslate nohighlight">\(b,c,b,a\)</span> which has length <span class="math notranslate nohighlight">\(4\)</span>.</p>
<section id="determining-subproblem-structure">
<h3>Determining subproblem structure<a class="headerlink" href="#determining-subproblem-structure" title="Link to this heading">#</a></h3>
<p>Continuing with the above example suppose we have a solution for the subproblem that consists of the first 3 elements of both lists</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
X_3 &amp;= x_1,x_2,x_3 = b,c,d  \\ 
Y_3 &amp;= y_1,y_2,y_3 = a,b,e
\end{align*}
\end{split}\]</div>
<p>the LCS here is clearly <span class="math notranslate nohighlight">\(b\)</span> which is of length <span class="math notranslate nohighlight">\(L_3^s=1\)</span>. Now for the next largest subproblem we will look at the next element in the two lists: <span class="math notranslate nohighlight">\(x_4=b\)</span> and <span class="math notranslate nohighlight">\(y_4=c\)</span>. There are two cases that can occur:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(x_4=y_4\)</span> in which case the new elements simply extend the LCS for the previous smaller subproblem by <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(L_4^s=L_3^s+1\)</span> and in the general case <span class="math notranslate nohighlight">\(L_i^s=L_{i-1}^s+1\)</span>.</p></li>
</ol>
<p><span class="math notranslate nohighlight">\(\qquad \qquad \qquad \Large{\textbf{or}}\)</span></p>
<ol class="arabic simple" start="2">
<li><p><span class="math notranslate nohighlight">\(x_4\not =y_4\)</span> (which is true for our current example since <span class="math notranslate nohighlight">\(x_4=b\)</span> and <span class="math notranslate nohighlight">\(y_4=c\)</span>) in which case there are three options: we can append either <span class="math notranslate nohighlight">\(x_4\)</span> <em><strong>or</strong></em> <span class="math notranslate nohighlight">\(y_4\)</span> <em><strong>or</strong></em> neither of them to the LCS. Clearly we can not append both since they are not equal and thus the resulting subsequence would not be a common subsequence. But how does it make sense that only appending one of <span class="math notranslate nohighlight">\(x_4\)</span> <strong>or</strong> <span class="math notranslate nohighlight">\(y_4\)</span> could work? The idea here is that the value of <span class="math notranslate nohighlight">\(x_4\)</span> could be one of the elements in string <span class="math notranslate nohighlight">\(Y_3\)</span> that came before <span class="math notranslate nohighlight">\(y_4\)</span> and thus by appending <span class="math notranslate nohighlight">\(x_4\)</span> to the string <span class="math notranslate nohighlight">\(X_3\)</span> we can extend the current LCS. The same logic applies to <span class="math notranslate nohighlight">\(y_4\)</span> but with the string <span class="math notranslate nohighlight">\(X_3\)</span>. And in fact the latter is exactly what happens here since <span class="math notranslate nohighlight">\(c\)</span> appears in <span class="math notranslate nohighlight">\(X_3\)</span> after the last element of the current LCS, i.e. <span class="math notranslate nohighlight">\(b\)</span>, if we append <span class="math notranslate nohighlight">\(y_4=c\)</span> to <span class="math notranslate nohighlight">\(Y_3\)</span> we will now have a longer LCS, i.e. <span class="math notranslate nohighlight">\(b,c\)</span>, which has length 2.</p></li>
</ol>
<p>In the case where <span class="math notranslate nohighlight">\(x_4\not=y_4\)</span> and neither are appended then the LCS is simply the LCS of the previous smallest subproblem, <span class="math notranslate nohighlight">\(L_3\)</span>, and the length is of course <span class="math notranslate nohighlight">\(L_3^s\)</span>. But wait if we only append <span class="math notranslate nohighlight">\(x_4\)</span> or <span class="math notranslate nohighlight">\(y_4\)</span> this leads to a problem. For example appending <span class="math notranslate nohighlight">\(x_4\)</span> would lead to the LCS only being defined for</p>
<div class="math notranslate nohighlight">
\[\begin{split}
X=x_1,x_2,x_3,x_4 \\
Y=y_1,y_2,y_3
\end{split}\]</div>
<p>but there could be another LCS that we can construct by appending <span class="math notranslate nohighlight">\(y_4\)</span> instead which would only be defined for</p>
<div class="math notranslate nohighlight">
\[\begin{split}
X=x_1,x_2,x_3 \\
Y=y_1,y_2,y_3,y_4
\end{split}\]</div>
<p>so what do we do? Well we’ll have to modify our subproblem definition. Instead of have just one index <span class="math notranslate nohighlight">\(i\)</span> we will have <em><strong>two</strong></em>, <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>, and subproblem <span class="math notranslate nohighlight">\(L_{i,j}\)</span> will be defined as finding the length of the LCS between the first <span class="math notranslate nohighlight">\(i\)</span> characters in <span class="math notranslate nohighlight">\(X\)</span> and the first <span class="math notranslate nohighlight">\(j\)</span> characters in <span class="math notranslate nohighlight">\(Y\)</span> i.e.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
X_i=x_1,x_2,...,x_i \\
Y_j=y_1,y_2,...,y_j
\end{split}\]</div>
<p>Note that this means instead of having a one-dimensional array/list to store our solutions to subproblems we will need a two-dimensional array since our problem now has two indices. Also note if the problem has input strings of length <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(m\)</span> respectively then the solution to this problem will be element <span class="math notranslate nohighlight">\(L_{nm}\)</span> of the two-dimensional array.</p>
<p>In the case where <span class="math notranslate nohighlight">\(x_i\not=y_i\)</span> and we append <span class="math notranslate nohighlight">\(y_j\)</span> and not <span class="math notranslate nohighlight">\(x_i\)</span>: the solution to the problem will be <span class="math notranslate nohighlight">\(L_{i-1,j}^s\)</span> meaning the length of the LCS will be the length of the LCS for the subproblem</p>
<div class="math notranslate nohighlight">
\[\begin{split}
X_{i-1}=x_1,x_2,...,x_{i-1} \\
Y_j=y_1,y_2,...,y_j
\end{split}\]</div>
<p>The case where we append <span class="math notranslate nohighlight">\(x_i\)</span> and not <span class="math notranslate nohighlight">\(y_j\)</span> similarly has the solution <span class="math notranslate nohighlight">\(L_{i,j-1}^s\)</span>. And the case where we append neither means we simply stick with the current best LCS which is the LCS for the subproblem <span class="math notranslate nohighlight">\(L_{i-1,j-1}\)</span> which would also be the solution to the subproblems <span class="math notranslate nohighlight">\(L_{i-1,j}\)</span> and <span class="math notranslate nohighlight">\(L_{i,j-1}\)</span>.</p>
<p>The recurrence for this problem is thus:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
L_{i,j}^s = \begin{cases}
\max\left\{L_{i-1,j}^s, L_{i,j-1}^s\right\} &amp;\quad \text{if} \quad x_i\not=y_j\\
L_{i-1,j-1}^s+1 &amp;\quad \text{if} \quad x_i=y_j
\end{cases} \quad \text{where} \quad 1\leq i\leq n, \quad  1\leq j\leq m
\end{split}\]</div>
<p>The base cases are</p>
<div class="math notranslate nohighlight">
\[\begin{split}
L_{i,0} = 0 \quad \text{where} \quad 1\leq i\leq n \\
L_{0,j} = 0 \quad \text{where} \quad  1\leq j\leq m
\end{split}\]</div>
<p>we set them to <span class="math notranslate nohighlight">\(0\)</span> since there is no common subsequence between a non-empty string and the empty string. Also note that the dimesnions of this array will be <span class="math notranslate nohighlight">\((n+1) \times (m+1)\)</span> since the first row and column are used to account for the case when one, or both, of the strings are the empty string.</p>
<p>For the problem</p>
<div class="math notranslate nohighlight">
\[\begin{split}
X=b,c,d,b,c,d,a \\ Y=a,b,e,c,b,a
\end{split}\]</div>
<p>we have the table <span class="math notranslate nohighlight">\(L^s\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
L^s = 
\begin{array}{cc} &amp; 
\begin{array}{ccccccc} \varnothing &amp; a &amp; b &amp; e &amp; c &amp; b &amp; a \end{array}
\\
\begin{array}{ccc}
\varnothing \\
b \\
c \\
d \\
b \\
c \\
d \\
a\end{array}
&amp;
\left[
\begin{array}{ccc}
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1  \\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2  \\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2  \\  
0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 3 &amp; 3  \\ 
0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 3 &amp; 3  \\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 3 &amp; 3  \\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 3 &amp; 4 
\end{array}
\right]\end{array}
\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(L_{8,7}\)</span> hold our answer which is the length of the subsequence <span class="math notranslate nohighlight">\(b,c,b,a\)</span> which is the LCS between <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span>. Note that <span class="math notranslate nohighlight">\(\varnothing\)</span> denotes the empty string.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">syp</span>

<span class="k">def</span> <span class="nf">LCS</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">]</span> <span class="c1"># base case </span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># note the +1 and -1 for some indices to account for the fact that python indexing starts at 0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span>  <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> 
            <span class="k">elif</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span>  <span class="nb">max</span><span class="p">(</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">T</span>


<span class="n">X</span> <span class="o">=</span> <span class="s2">&quot;bcdbcda&quot;</span> 
<span class="n">Y</span> <span class="o">=</span> <span class="s2">&quot;abecba&quot;</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">LCS</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">)</span>
<span class="n">syp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}\displaystyle \left[\begin{matrix}0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2\\0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2\\0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 3 &amp; 3\\0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 3 &amp; 3\\0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 3 &amp; 3\\0 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 3 &amp; 4\end{matrix}\right]\end{split}\]</div>
</div>
</div>
</section>
</section>
<section id="knapsack">
<h2>Knapsack<a class="headerlink" href="#knapsack" title="Link to this heading">#</a></h2>
<p>Knapsack is a well known optimization problem. Given a knapsack of weight capacity <span class="math notranslate nohighlight">\(B\)</span> and a set <span class="math notranslate nohighlight">\(N\)</span> of <span class="math notranslate nohighlight">\(n\)</span> items with integer weights <span class="math notranslate nohighlight">\(W=\{w_1,...,w_n\}\)</span> and corresponding integer values <span class="math notranslate nohighlight">\(V=\{v_1,...,v_n\}\)</span> find a subset <span class="math notranslate nohighlight">\(S\)</span> of the items that maximizes the total value while not exceeding the capacity <span class="math notranslate nohighlight">\(B\)</span> of the knapsack. Note that the requirement that the weights and values are integers can be, and often is, relaxed to included non-negative real numbers but for this section we will not relax that constraint as it makes the dynamic programming approach more difficult.</p>
<div class="math notranslate nohighlight">
\[
\arg\max_S \left\{ \sum_{i\in S} v_i \right\} \quad \text{where} \quad \sum_{i\in S} w_i \leq B
\]</div>
<p>For this section we will look at two variants of this problem. In one variation we can include each object at most once in our subset <span class="math notranslate nohighlight">\(S\)</span> (no repetition). In the other variant we can include each object as many times as we want. This means <span class="math notranslate nohighlight">\(S\)</span> is no longer a proper set, but we will just refer to it as one for simplicity. We’ll consider the former first.</p>
<section id="no-repetition">
<h3>No repetition<a class="headerlink" href="#no-repetition" title="Link to this heading">#</a></h3>
<p>A greedy approach of taking the items with the most value or the items with the most value to weight ratio <span class="math notranslate nohighlight">\(\frac{v_i}{w_i}\)</span> will fail for this problem as shown by Dr. Vigoda in lecture. Let’s try to solve this using dynamic programming. As always let’s try to define our subproblems as just smaller versions of the overall problem so we will define <span class="math notranslate nohighlight">\(K(i)\)</span> as the maximum value attainable using the first <span class="math notranslate nohighlight">\(i\)</span> items, so <span class="math notranslate nohighlight">\(V_i=\{v_1,...,v_i\}\)</span> and <span class="math notranslate nohighlight">\(W_i=\{w_1,...,w_i\}\)</span>, such that the total weight of the items in the knapsack do not exceed <span class="math notranslate nohighlight">\(B\)</span>. Let’s take a simple example where our problem is</p>
<div class="math notranslate nohighlight">
\[\begin{split} 
\begin{align*}
V &amp;= \{v_1=15,v_2=10,v_3=8,v_4=1\}\\
W &amp;= \{w_1=15,w_2=12,w_3=10,w_4=5\}\\
B &amp;= 22
\end{align*}
\end{split}\]</div>
<p>So what’s <span class="math notranslate nohighlight">\(K(1)\)</span>? Well we can only choose item <span class="math notranslate nohighlight">\(1\)</span> or nothing and since item 1 fits in the bag that is our solution so <span class="math notranslate nohighlight">\(K(1)=v_1=15\)</span>. Now what about <span class="math notranslate nohighlight">\(K(2)\)</span>? Well we can only pick between items <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(2\)</span> now. It is easy to see the maximum value is attained by just using item 1 again since both items <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(2\)</span> can not fit in the knapsack together and item <span class="math notranslate nohighlight">\(1\)</span> has larger value than item 2 so <span class="math notranslate nohighlight">\(K(2)=v_1=15\)</span>.</p>
<p>Now what about <span class="math notranslate nohighlight">\(K(3)\)</span>? Now we can pick any subset from items <span class="math notranslate nohighlight">\(1,2, 3\)</span>. From inspection, we can see that the maximum value is attainable by using items <span class="math notranslate nohighlight">\(2\)</span> and <span class="math notranslate nohighlight">\(3\)</span> so <span class="math notranslate nohighlight">\(K(3)=v_2+v_3=18\)</span>. But wait can we use the solutions to the previous subproblems <span class="math notranslate nohighlight">\(K(1)\)</span> and <span class="math notranslate nohighlight">\(K(2)\)</span> to come to this solution? Nope since the solutions to both of those problems only utilize item <span class="math notranslate nohighlight">\(1\)</span> there is no way we can construct the optimal solution to <span class="math notranslate nohighlight">\(K(3)\)</span> using them. So we have run into the same problem we ran into for LIS and LCS: our subproblem definition is not optimal.</p>
<section id="better-subproblem-definition">
<h4>Better subproblem definition<a class="headerlink" href="#better-subproblem-definition" title="Link to this heading">#</a></h4>
<p>Since we would have needed the solution to <span class="math notranslate nohighlight">\(K(2)\)</span> to use item <span class="math notranslate nohighlight">\(2\)</span> instead of item <span class="math notranslate nohighlight">\(1\)</span> this indicates that we will have to have subproblem definition that leads to use getting a suboptimal (with respect to the definition we have currently) solution to <span class="math notranslate nohighlight">\(K(2)\)</span>. What’s more is that we need this suboptimal solution to leave enough capacity in the knapsack to include item <span class="math notranslate nohighlight">\(3\)</span>. For example in this case we would want to find the optimal solution to <span class="math notranslate nohighlight">\(K(2)\)</span> but with the capacity of the knapsack adjust to <span class="math notranslate nohighlight">\(B-w_3=12\)</span>. In this case the solution is to keep item <span class="math notranslate nohighlight">\(2\)</span> and so <span class="math notranslate nohighlight">\(K(2)=v_2=10\)</span>. Let’s see if we can make this more general. It seems like we may have to consider subproblems of smaller size in two senses: 1) with a smaller subset of the items and 2) with a smaller capacity than <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>Our subproblem can thus be defined as:</p>
<p><span class="math notranslate nohighlight">\(K(i,b)\)</span> is the maximum value attainable using the first <span class="math notranslate nohighlight">\(i\)</span> items and a total knapsack capacity of <span class="math notranslate nohighlight">\(b\leq B\)</span>.</p>
<p>Using this definition we now have 2 cases that can occur:</p>
<ol class="arabic">
<li><p>The <span class="math notranslate nohighlight">\(i\)</span>-th item has weight <span class="math notranslate nohighlight">\(w_i\leq b\)</span> meaning it can fit in the knapsack in which case the optimal value we can get is whichever of the following is greater:</p>
<p>a) the value from keeping the item</p>
<p>b) the value from not keeping the item.</p>
<p>If we keep the item then our solution will be <span class="math notranslate nohighlight">\(v_i+K(i-1,b-w_i)\)</span> i.e. it is solution to the subproblem that doesn’t include item <span class="math notranslate nohighlight">\(i\)</span> and where the knapsack capacity is <span class="math notranslate nohighlight">\(b-w_i\)</span> <em>plus</em> the value of item <span class="math notranslate nohighlight">\(i\)</span>. We use the solution with capacity <span class="math notranslate nohighlight">\(b-w_i\)</span> since we are including item <span class="math notranslate nohighlight">\(i\)</span>. If we don’t keep the item the solution is simply <span class="math notranslate nohighlight">\(K(i-1,b)\)</span>.</p>
</li>
</ol>
<p><span class="math notranslate nohighlight">\(\qquad \qquad \qquad \Large{\textbf{or}}\)</span></p>
<ol class="arabic simple" start="2">
<li><p>The <span class="math notranslate nohighlight">\(i\)</span>-th item has weight <span class="math notranslate nohighlight">\(w_i &gt; b\)</span> meaning it can <em>not</em> fit in the knapsack in which case we don’t keep it and the solution is simply <span class="math notranslate nohighlight">\(K(i-1,b)\)</span>.</p></li>
</ol>
<p>This yields the elegant recurrence relation</p>
<div class="math notranslate nohighlight">
\[\begin{split}
K(i,b) = \begin{cases} 
      \max\{v_i+K(i-1,b-w_i), \quad K(i-1,b)\} &amp;\quad\text{if}\quad w_i\leq b\\
      K(i-1,b)  &amp;\quad\text{otherwise} \\
   \end{cases}\\
   \text{where} \quad 0\leq i \leq n, \quad 0\leq b \leq B
\end{split}\]</div>
<p>with the base cases <span class="math notranslate nohighlight">\(K(0,b)=K(i,0)=0\)</span> which correspond to the case where we have no items and no knapsack (0 capacity) respectively. And of course the solution to our overall problem will be the bottom rightmost element of the resulting table: <span class="math notranslate nohighlight">\(K(n,B)\)</span>. Below is an example of such a table.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
K = 
\begin{array}{cc} &amp; 
\begin{array}{ccccccc} 0 &amp; \quad 1 &amp; \quad 2 &amp; \quad 3 &amp; \quad 4 &amp; \quad \cdots &amp; \quad B \end{array}
\\
\begin{array}{ccc}
0 \\
1 \\
2 \\
3 \\
4 \\
\vdots \\
n\end{array}
&amp;
\left[
\begin{array}{ccc}
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0  \\
0 &amp; K_{1,1} &amp; K_{1,2} &amp; K_{1,3} &amp; K_{1,4} &amp; \cdots &amp; K_{1,B}  \\
0 &amp; K_{2,1} &amp; K_{2,2} &amp; K_{2,3} &amp; K_{2,4} &amp; \cdots &amp; K_{2,B}  \\
0 &amp; K_{3,1} &amp; K_{3,2} &amp; K_{3,3} &amp; K_{3,4} &amp; \cdots &amp; K_{3,B}  \\  
0 &amp; K_{4,1} &amp; K_{4,2} &amp; K_{4,3} &amp; K_{4,4} &amp; \cdots &amp; K_{4,B}  \\ 
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots  \\
0 &amp; K_{n,1} &amp; K_{n,2} &amp; K_{n,3} &amp; K_{n,4} &amp; \cdots &amp; K_{n,B}
\end{array}
\right]\end{array}
\end{split}\]</div>
</section>
<section id="complexity">
<h4>Complexity<a class="headerlink" href="#complexity" title="Link to this heading">#</a></h4>
<p>Clearly the time complexity of this approach will be <span class="math notranslate nohighlight">\(O(nB)\)</span> since we must fill out the 2D table <span class="math notranslate nohighlight">\(K\)</span> of size <span class="math notranslate nohighlight">\(n\times B\)</span> and each entry takes <span class="math notranslate nohighlight">\(O(1)\)</span> time to compute. Not bad since it’s polynomial (linear) in both the number of items <span class="math notranslate nohighlight">\(n\)</span> and the capacity of the knapsack <span class="math notranslate nohighlight">\(B\)</span> right? This is where we have to be careful about complexity. Recall that while time complexity is defined as the number of elementary operations we must perform to solve a problem of a given input size what we really mean is with respect to the input size <em>in bits</em>. For example merge sort has an input size of <span class="math notranslate nohighlight">\(n\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of elements in the list <span class="math notranslate nohighlight">\(L=[a_1,a_2,...,a_n]\)</span> to be sorted. For each number <span class="math notranslate nohighlight">\(a_i\in L\)</span> we will need <span class="math notranslate nohighlight">\(\approx \log_2{a_i}\)</span> bits to represent it and so the input size in bits is on the order of <span class="math notranslate nohighlight">\(n\log_2{a_1}\)</span> (assuming all the numbers are near <span class="math notranslate nohighlight">\(a_1\)</span> in magnitude) since we have <span class="math notranslate nohighlight">\(n\)</span> numbers. For merge sort we know we have a complexity of <span class="math notranslate nohighlight">\(O(n\log_2{n})\)</span>. This is log-linear in the input size since it grows log-linearly as the input size, <span class="math notranslate nohighlight">\(n\log_2{a_1}\)</span>, increases.</p>
<p>However, for knapsack we have two lists of <span class="math notranslate nohighlight">\(n\)</span> numbers, the values of the items and their weights, which we can say need on the order of <span class="math notranslate nohighlight">\(n\log_2{w_1}+n\log_2{v_1}\)</span> bits to represent them. So our complexity of <span class="math notranslate nohighlight">\(O(nB)\)</span> is indeed polynomial (linear) in the input size <span class="math notranslate nohighlight">\(n\)</span> right? If we only look at the number of bits needed to represent the weights and values yes that would be the case but what about the other input to the problem: <span class="math notranslate nohighlight">\(B\)</span>? Well it takes <span class="math notranslate nohighlight">\(\log_2{B}\)</span> bits to represent <span class="math notranslate nohighlight">\(B\)</span> so our input size is actually on the order of  <span class="math notranslate nohighlight">\(n\log_2{w_1}+n\log_2{v_1}+\log_2{B}\)</span> bits. Now lets look closely at our algorithms’ complexity again. For an input size of <span class="math notranslate nohighlight">\(n\log_2{w_1}+n\log_2{v_1}+\log_2{B}\)</span> this complexity tells us we will need to perform on the order of <span class="math notranslate nohighlight">\(nB\)</span> elementary operations to solve the problem. This means we have to perform <em>exponentially</em> more operations than the size of our input since <span class="math notranslate nohighlight">\(B\)</span> (which is linear in <span class="math notranslate nohighlight">\(B\)</span>) grow exponentially faster than <span class="math notranslate nohighlight">\(\log_2{B}\)</span> (which is logarithmic in <span class="math notranslate nohighlight">\(B\)</span>). Another way to say this is: while our input size grows logarithmically with <span class="math notranslate nohighlight">\(B\)</span> the number of elementary operations we need to perform to solve a problem of that input size grows linearly with <span class="math notranslate nohighlight">\(B\)</span> which is an exponential gap. So while this algorithm is polynomial in the part of the input size, i.e. with respect to the weights and values <span class="math notranslate nohighlight">\(n\log_2{w_1}+n\log_2{v_1}\)</span>, it is exponential in the size of <span class="math notranslate nohighlight">\(B\)</span>. And in fact the knapsack problem is known to be <em><strong>NP-complete</strong></em>.</p>
</section>
</section>
<section id="with-repetition">
<h3>With repetition<a class="headerlink" href="#with-repetition" title="Link to this heading">#</a></h3>
<p>Now let’s consider the case where we can include as many copies of an item in our knapsack as we want (assuming it can hold them) instead of at most one copy. This case is actually simpler. Let’s define our subproblems as:</p>
<p><span class="math notranslate nohighlight">\(K(b)\)</span> is the maximum value attainable using a knapsack with capacity <span class="math notranslate nohighlight">\(0\leq b \leq B\)</span>.</p>
<p>In this case we have the recurrence</p>
<div class="math notranslate nohighlight">
\[\begin{split}
K(b) = \max_i\left\{v_i + K(b-w_i) \bigg| w_i\leq b\right\} \\
\text{where} \quad 1\leq i \leq n
\end{split}\]</div>
<p>which I read as saying: the maximum value attainable using a knapsack of capacity <span class="math notranslate nohighlight">\(b\)</span> is the maximum value attainable from using a knapsack of capacity <span class="math notranslate nohighlight">\(b-w_i\)</span> where <span class="math notranslate nohighlight">\(w_i\leq b\)</span> plus the value of item <span class="math notranslate nohighlight">\(i\)</span> i.e. <span class="math notranslate nohighlight">\(v_i\)</span>. We don’t know what item <span class="math notranslate nohighlight">\(i\)</span> this will be so must look at all of them. Note that we can end up using multiple copies of an item with this recurrence since we do not track <span class="math notranslate nohighlight">\(i\)</span> as part of our table anymore. However, even though we don’t  have a 2D table anymore the complexity is still <span class="math notranslate nohighlight">\(O(nB)\)</span> since for each possible capacity <span class="math notranslate nohighlight">\(b\in\{1,2,...,B\}\)</span> we must look at all <span class="math notranslate nohighlight">\(n\)</span> items to determine which will provide the optimal value when included. Our answer will of course be the value at the end of this table we construct: <span class="math notranslate nohighlight">\(K(B)\)</span>.</p>
</section>
</section>
<section id="chain-matrix-multiplication">
<h2>Chain matrix multiplication<a class="headerlink" href="#chain-matrix-multiplication" title="Link to this heading">#</a></h2>
<p>Let’s go over the second example of an application of dynamic programming which is covered extensively in <span id="id9">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span> and rather briefly in <span id="id10">[<a class="reference internal" href="../../backmatter/bibliography.html#id29" title="Sanjoy Dasgupta, Christos H Papadimitriou, and Umesh Virkumar Vazirani. Algorithms. McGraw-Hill Higher Education New York, 2008.">Dasgupta <em>et al.</em>, 2008</a>]</span>. Suppose we have a chain of <span class="math notranslate nohighlight">\(n\)</span> matrices  we want to multiply together</p>
<div class="math notranslate nohighlight">
\[
P = A_1A_2A_3...A_n
\]</div>
<p>where matrix <span class="math notranslate nohighlight">\(A_1\)</span> has shape <span class="math notranslate nohighlight">\(m_0\times m_1\)</span> and matrix <span class="math notranslate nohighlight">\(A_2\)</span> has shape <span class="math notranslate nohighlight">\(m_1\times m_2\)</span> and so on. We would like to devise an algorithm to do this optimally. Optimally in what sense though? Matrix multiplication is not commutative, i.e. <span class="math notranslate nohighlight">\(AB \not =BA\)</span> in general, so we can not swap the order of the matrices in the product. However, matrix multiplication is associative, i.e. <span class="math notranslate nohighlight">\((AB)C=A(BC)\)</span>, so we can choose which of the two term products to compute before others.</p>
<p>Recall that (naively) multiplying a <span class="math notranslate nohighlight">\(m\times n\)</span> matrix with a <span class="math notranslate nohighlight">\(n\times p\)</span> matrix has time complexity (which is measured in scalar multiplications) <span class="math notranslate nohighlight">\(O(mnp)\)</span> which reduces to the familiar <span class="math notranslate nohighlight">\(O(n^3)\)</span> for square matrices. Suppose we want to calculate <span class="math notranslate nohighlight">\(P=A_1A_2A_3\)</span> where the corresponding shapes are <span class="math notranslate nohighlight">\(100 \times 20, 20 \times 200, 200 \times 15\)</span> respectively.</p>
<p>First let’s find the complexity of computing</p>
<div class="math notranslate nohighlight">
\[
P=(A_1A_2)A_3.
\]</div>
<p>The product in parentheses has complexity <span class="math notranslate nohighlight">\(100 \times 20 \times 200 = 400,000\)</span> and results in a <span class="math notranslate nohighlight">\(100 \times 200\)</span> matrix. Then the complexity of multiplying this resulting matrix with <span class="math notranslate nohighlight">\(A_3\)</span> is <span class="math notranslate nohighlight">\(100 \times 200 \times 15 = 300,000\)</span> for a total complexity of <span class="math notranslate nohighlight">\(400,000+300,000=700,000\)</span>.</p>
<p>Now what if we compute the product as</p>
<div class="math notranslate nohighlight">
\[
P=A_1(A_2A_3)?
\]</div>
<p>The product in parentheses has complexity <span class="math notranslate nohighlight">\(20 \times 200 \times 15 = 60,000\)</span> and results in a <span class="math notranslate nohighlight">\(20 \times 15\)</span> matrix. Then the complexity of multiplying this resulting matrix with <span class="math notranslate nohighlight">\(A_1\)</span> is <span class="math notranslate nohighlight">\(100 \times 20 \times 15 = 30,000\)</span> for a total complexity of <span class="math notranslate nohighlight">\(60,000+30,000=90,000\)</span>. From this we can see that choosing how to parenthesize the products can have a <em>drastic</em> effect on the complexity of the overall multi-matrix product computation. Can we devise an algorithm to find the <em>optimal</em> parenthesization given a list of matrix shapes that we want to multiply?</p>
<section id="id11">
<h3>Bottom-up approach<a class="headerlink" href="#id11" title="Link to this heading">#</a></h3>
<p>We can solve this problem using a bottom-up approach as laid out by <span id="id12">[<a class="reference internal" href="../../backmatter/bibliography.html#id29" title="Sanjoy Dasgupta, Christos H Papadimitriou, and Umesh Virkumar Vazirani. Algorithms. McGraw-Hill Higher Education New York, 2008.">Dasgupta <em>et al.</em>, 2008</a>]</span> and Dr. Vigoda’s lecture. It is also laid out extensively in <span id="id13">[<a class="reference internal" href="../../backmatter/bibliography.html#id28" title="Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. Introduction to algorithms. MIT press, 2022.">Cormen <em>et al.</em>, 2022</a>]</span>. First it’s useful to observe that different parenthesizations can be represented as binary trees. For example look at the below image.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">display</span><span class="p">(</span><span class="n">Image</span><span class="p">(</span><span class="s2">&quot;img/cmm_tree.png&quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">700</span><span class="p">))</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<a class="reference internal image-reference" href="../../_images/90122de2b344f9aabeafcb5734d56ea62dff7ff2ca025be7c595fd657692ea11.png"><img alt="../../_images/90122de2b344f9aabeafcb5734d56ea62dff7ff2ca025be7c595fd657692ea11.png" src="../../_images/90122de2b344f9aabeafcb5734d56ea62dff7ff2ca025be7c595fd657692ea11.png" style="width: 700px;" /></a>
</div>
</div>
<p>The leftmost binary tree corresponds to the parenthesizations <span class="math notranslate nohighlight">\(((AB)C)D\)</span>, the middle corresponds to <span class="math notranslate nohighlight">\(A((BC)D)\)</span> and the rightmost to <span class="math notranslate nohighlight">\((A(BC))D\)</span>. The leaves correspond to the four matrices and the internal nodes corresponds to the intermediate products such as <span class="math notranslate nohighlight">\(AB\)</span> or <span class="math notranslate nohighlight">\((AB)C\)</span> for the case of the left most tree. The root corresponds to the overall product.</p>
<section id="characterize-the-structure-of-an-optimal-solution-parenthesization">
<h4>1. Characterize the structure of an optimal solution (parenthesization)<a class="headerlink" href="#characterize-the-structure-of-an-optimal-solution-parenthesization" title="Link to this heading">#</a></h4>
<p>Suppose that we have an optimal parenthesization for the <span class="math notranslate nohighlight">\(n\)</span> matrix product <span class="math notranslate nohighlight">\(P_{\text{opt}}=A_1A_2A_3...A_n\)</span>. Now suppose we take this solution and split it into two chains at <span class="math notranslate nohighlight">\(A_k\)</span> such that we have <span class="math notranslate nohighlight">\(P_{\text{opt}}^L=A_1A_2...A_k\)</span> and <span class="math notranslate nohighlight">\(P_{\text{opt}}^R=A_{k+1}A_{k+2}...A_n\)</span> and clearly <span class="math notranslate nohighlight">\(P_{\text{opt}} = P_{\text{opt}}^LP_{\text{opt}}^R\)</span>. Since we know <span class="math notranslate nohighlight">\(P_{\text{opt}}\)</span> has an optimal parenthesization then we also know that the parenthesization of <span class="math notranslate nohighlight">\(P_{\text{opt}}^L\)</span> is optimal. Why is this the case? Well if it wasn’t the case and there was another parenthesization that was optimal for <span class="math notranslate nohighlight">\(P_{\text{opt}}^L\)</span> then we can use that same parenthesization in the overall product in <span class="math notranslate nohighlight">\(P_{\text{opt}}=A_1A_2A_3...A_n\)</span> to make it more optimal. But this is a contradiction since we stated at the beginning that <span class="math notranslate nohighlight">\(P_{\text{opt}}\)</span> is already optimal. Therefore if <span class="math notranslate nohighlight">\(P_{\text{opt}}=A_1A_2A_3...A_n\)</span> is an optimal parenthesization then the parenthesizations for sub-chains of the chain when considered in isolation must also be optimal. For example if <span class="math notranslate nohighlight">\(P_{\text{opt}}=(A_1(A_2(A_3A_4)))\)</span> then <span class="math notranslate nohighlight">\((A_2(A_3A_4))\)</span> must also be an optimal parenthesization for the produce <span class="math notranslate nohighlight">\(A_2A_3A_4\)</span>. In <span id="id14">[<a class="reference internal" href="../../backmatter/bibliography.html#id29" title="Sanjoy Dasgupta, Christos H Papadimitriou, and Umesh Virkumar Vazirani. Algorithms. McGraw-Hill Higher Education New York, 2008.">Dasgupta <em>et al.</em>, 2008</a>]</span> the authors say the same thing about the binary trees that represent a parenthesization: for a binary tree to be optimal it’s subtrees must also be optimal.</p>
<p>This <em><strong>partially</strong></em> goes in the other direction as well: an optimal solution to parenthesizing <span class="math notranslate nohighlight">\(A_1A_2A_3...A_n\)</span> can be constructed by splitting the chain into two parts and finding optimal parenthesizing of the two resulting chains and multiplying them together (combining the solutions). The problem is that we do not know <em>which</em> split, i.e. splitting at <span class="math notranslate nohighlight">\(k=1\)</span>, <span class="math notranslate nohighlight">\(k=2\)</span> etc, is optimal so we have to try all of them much like the rod cutting problem. But as with rod cutting we will find that we can exploit the repeated occurrence of subproblems to drastically cut down the number of computations we must perform.</p>
<div class="dropdown admonition note">
<p class="admonition-title">Note</p>
<p>I say it partially goes in the other direction because in general it is not true that all splits can yield an optimal solution. For example if <span class="math notranslate nohighlight">\((A(B(C(EF)G)))\)</span> is an optimal parenthesization we can certainly find instances where an optimal parenthesization of <span class="math notranslate nohighlight">\(ABC\)</span>, when found without considering <span class="math notranslate nohighlight">\(EDF\)</span>, is not an optimal parenthesization for the overall chain when multiplied by the optimal parenthesization of <span class="math notranslate nohighlight">\(EDF\)</span> which was also found without considering <span class="math notranslate nohighlight">\(ABC\)</span>.</p>
</div>
</section>
<section id="recursively-define-the-value-of-an-optimal-solution">
<h4>2. Recursively define the value of an optimal solution<a class="headerlink" href="#recursively-define-the-value-of-an-optimal-solution" title="Link to this heading">#</a></h4>
<p>First for a problem of inputs size <span class="math notranslate nohighlight">\(n\)</span>, i.e. <span class="math notranslate nohighlight">\(P=A_1A_{2}...A_n\)</span>, we will define <span class="math notranslate nohighlight">\(A_{i:j}\)</span> to be the matrix that results from computing <span class="math notranslate nohighlight">\(A_iA_{i+1}...A_j\)</span> where <span class="math notranslate nohighlight">\(1\leq i \leq j \leq n\)</span>. We are given the dimensions of the matrices as a list <span class="math notranslate nohighlight">\([m_0,m_1,...m_n]\)</span> such that matrix <span class="math notranslate nohighlight">\(A_i\)</span> is of shape <span class="math notranslate nohighlight">\(m_{i-1}\times m_i\)</span>. Let <span class="math notranslate nohighlight">\(s[i,j]\)</span> be the minimum number of scalar multiplications needed to compute the matrix <span class="math notranslate nohighlight">\(A_{i:j}\)</span> resulting from the chain <span class="math notranslate nohighlight">\(A_iA_{i+1}...A_j\)</span>. We want to find a parenthesization that results in <span class="math notranslate nohighlight">\(s[1,n]\)</span> scalar multiplications since <span class="math notranslate nohighlight">\(s[1,n]\)</span> the minimum number of scalar multiplications needed to compute the whole chain. There are 2 cases either</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(i=j\)</span> in which case we only have one matrix and the minimum number of scalar multiplications needed to compute it are 0 (we’re not multiplying anything) so  <span class="math notranslate nohighlight">\(s[i,i]=0 \quad \forall i \in \{1,2,...,n\}\)</span></p></li>
</ol>
<p><span class="math notranslate nohighlight">\(\qquad \qquad \qquad \Large{\textbf{or}}\)</span></p>
<ol class="arabic simple" start="2">
<li><p><span class="math notranslate nohighlight">\(i&lt;j\)</span> (we ignore cases where <span class="math notranslate nohighlight">\(i&gt;j\)</span> since they are covered) in which case we have the product <span class="math notranslate nohighlight">\(A_iA_{i+1}...A_j\)</span> to compute. Suppose an optimal parenthesization splits the product at <span class="math notranslate nohighlight">\(A_k\)</span> where <span class="math notranslate nohighlight">\(i \leq k &lt; j\)</span>. Then <span class="math notranslate nohighlight">\(s[i,j]\)</span> is equal to the minimum number of scalar multiplications to compute <span class="math notranslate nohighlight">\(A_{i:k}\)</span>, i.e. <span class="math notranslate nohighlight">\(s[i,k]\)</span>, plus the minimum number of scalar multiplications to compute <span class="math notranslate nohighlight">\(A_{k+1:j}\)</span>, i.e. <span class="math notranslate nohighlight">\(s[k+1,j]\)</span>, plus the number of scalar multiplications needed to multiply the two resulting matrices <span class="math notranslate nohighlight">\(A_{i:k}\)</span> and <span class="math notranslate nohighlight">\(A_{k+1:j}\)</span>. The shape of <span class="math notranslate nohighlight">\(A_{i:k}\)</span> will be <span class="math notranslate nohighlight">\(m_{i-1} \times m_k\)</span> and the shape of <span class="math notranslate nohighlight">\(A_{k+1:j}\)</span> will be <span class="math notranslate nohighlight">\(m_k \times m_j\)</span> and so it will take <span class="math notranslate nohighlight">\(m_{i-1}m_km_j\)</span> scalar multiplications to compute their product at a minimum. Thus we can express <span class="math notranslate nohighlight">\(s[i,j]\)</span> as</p></li>
</ol>
<div class="math notranslate nohighlight">
\[
s[i,j] = s[i,k] + s[k+1,j] + m_{i-1}m_km_j
\]</div>
<p>The recurrence for this problem is thus given by</p>
<div class="math notranslate nohighlight">
\[
s(i,j) = \min_{i\leq k &lt; j}\{ s(i,k) + s(k+1,j)  + m_{i-1}m_km_j\} \quad \text{where} \quad 1 \leq i \leq j \leq n
\]</div>
<p>with the base cases</p>
<div class="math notranslate nohighlight">
\[
s(i,i) = 0 \quad \text{where} \quad 1 \leq i \leq n
\]</div>
<p>Notice that to this is a 2D table put the time complexity of this algorithm will actually be <span class="math notranslate nohighlight">\(O(n^3)\)</span>. Why not <span class="math notranslate nohighlight">\(O(n^2)\)</span>? Because of the <span class="math notranslate nohighlight">\(i\leq k &lt; j\)</span> in the <span class="math notranslate nohighlight">\(\min\)</span> which arises because we have to consider all <em>substrings</em> of the input as our subproblems as opposed to just the first <span class="math notranslate nohighlight">\(i\)</span> elements of the input which was the case for problems such as LIS and LCS.</p>
</section>
</section>
</section>
<section id="shortest-paths">
<h2>Shortest paths<a class="headerlink" href="#shortest-paths" title="Link to this heading">#</a></h2>
<p>The Bellman-Ford algorithm for finding the shortest path between a node <span class="math notranslate nohighlight">\(s\)</span> and another node <span class="math notranslate nohighlight">\(t\)</span> in a graph and the Floyd-Warshall algorithm for finding the shortest path between all pairs of nodes in a graph can be understood as dynamic programming algorithms.</p>
</section>
<section id="practice-problems">
<h2>Practice problems<a class="headerlink" href="#practice-problems" title="Link to this heading">#</a></h2>
<p>These are problems from chapter 6 of the DPV textbook. Note that for these problems I will use <span class="math notranslate nohighlight">\(T(i)\)</span> or <span class="math notranslate nohighlight">\(T(i,j)\)</span> to denote the table entries whereas above I use <span class="math notranslate nohighlight">\(L_i\)</span> or <span class="math notranslate nohighlight">\(L_{ij}\)</span> for the subsequence problems and <span class="math notranslate nohighlight">\(K(i,j)\)</span> for the knapsack problems.</p>
<section id="maximal-contiguous-subsequence">
<h3>6.1 Maximal Contiguous Subsequence<a class="headerlink" href="#maximal-contiguous-subsequence" title="Link to this heading">#</a></h3>
<p>Given a list of numbers</p>
<div class="math notranslate nohighlight">
\[
L_n = a_1,a_2,...,a_n
\]</div>
<p>we want to find the sum of the <em>contiguous</em> subsequence of maximal sum. This problem is nice since we are dealing with contiguous subsequences so there’s no need to consider previous solutions to all previous subproblems.</p>
<p>The recurrence for this problem is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
T(i) &amp;= \max\{ T(i-1) + a_i, \quad a_i \} \\
&amp;= \max\{ T(i-1), \quad 0 \} + a_i
\end{align*}
\end{split}\]</div>
<p>with a base case of <span class="math notranslate nohighlight">\(T(0)=0\)</span> and where <span class="math notranslate nohighlight">\(1\leq i \leq n\)</span>.</p>
<p>This essentially says the solution to subproblem <span class="math notranslate nohighlight">\(i\)</span> will be constructed by either 1) appending <span class="math notranslate nohighlight">\(a_i\)</span> to the end of the solution for the <span class="math notranslate nohighlight">\(i-1\)</span>-th subproblem or 2) only including <span class="math notranslate nohighlight">\(a_i\)</span>. This is very similar to the constraint we had for LIS i.e. <span class="math notranslate nohighlight">\(a_i\)</span> must be included in the solution to subproblem <span class="math notranslate nohighlight">\(i\)</span>. Once we have the full array/table <span class="math notranslate nohighlight">\(T\)</span> we simply find it’s max value and this will be the value of the sum of the contiguous subsequence of maximal sum. Again the same logic applies here as for LIS: since the contiguous subsequence of maximal value must end with <em>one</em> of the elements from <span class="math notranslate nohighlight">\(L_n\)</span> and we have solved for the contiguous subsequence of maximal sum that ends with <span class="math notranslate nohighlight">\(a_i\)</span> <span class="math notranslate nohighlight">\(\forall i\in\{1,...,n\}\)</span> we know at least <em>one</em> of the values in our table corresponds to the sum of the contiguous subsequence of maximal sum i.e. the one with the largest value.</p>
<p>The below algorithm has complexity <span class="math notranslate nohighlight">\(O(n)\)</span> in both time and space. You could get this down to <span class="math notranslate nohighlight">\(O(1)\)</span> space complexity by just keeping track of the maximum value as you make your way through the subproblems.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">p1</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">nums</span> <span class="o">==</span> <span class="p">[]:</span> <span class="c1"># if empty list </span>
        <span class="k">return</span> <span class="mi">0</span>
        
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># the solution to the smallest non-trivial subproblem is simply nums[0] since it is the only element in the array</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># the solution to subproblem i will either </span>
        <span class="c1"># 1) be appending nums[i] to the end of the solution for subproblem i-1 (the previous smaller subproblem) OR</span>
        <span class="c1"># 2) the solution will just be the element nums[i] itself.</span>
        <span class="c1"># This follows from the constraint that this must be a contiguous subarray/subsequence</span>
        <span class="k">if</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> 
            <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>

<span class="n">test</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p1</span><span class="p">(</span><span class="n">test</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>55
</pre></div>
</div>
</div>
</div>
</section>
<section id="hotel-stops">
<h3>6.2 Hotel Stops<a class="headerlink" href="#hotel-stops" title="Link to this heading">#</a></h3>
<p>So the idea here is fairly straightforward. Given a sequence of <span class="math notranslate nohighlight">\(n\)</span> hotels with distances <span class="math notranslate nohighlight">\(a_i\)</span> from the starting point</p>
<div class="math notranslate nohighlight">
\[
a_1,a_2,...,a_n.
\]</div>
<p>The subproblems are simply: what is the optimal sequence of stops for the sequence</p>
<div class="math notranslate nohighlight">
\[
a_1,a_2,...,a_i \quad\text{Where $1\leq i \leq n$}
\]</div>
<p>that ends with the final stop <span class="math notranslate nohighlight">\(a_i\)</span>.</p>
<p>The solution to subproblem <span class="math notranslate nohighlight">\(i\)</span> will either be</p>
<ol class="arabic simple">
<li><p>Taking <em>one of</em> the optimal sequence of stops found for the previous smaller subproblems and then driving from the ending hotel of that solution to <span class="math notranslate nohighlight">\(a_i\)</span>. We compute the penalty for taking each route by adding the penalty for that subproblem solution with the penalty of driving from the final destination/hotel in that subproblem to the final hotel <span class="math notranslate nohighlight">\(a_i\)</span> in our current subproblem. The latter term in the sum is computed as <span class="math notranslate nohighlight">\(\left(200-(a_i-a_j)\right)^2\)</span> for previous subproblem <span class="math notranslate nohighlight">\(j\)</span>. If one of these routes yields a penalty lower than <span class="math notranslate nohighlight">\((200-a_i)^2\)</span> and it is the smallest penalty found after iterating over all past optimal routes then it is the optimal route for subproblem <span class="math notranslate nohighlight">\(i\)</span>.</p></li>
</ol>
<p><span class="math notranslate nohighlight">\(\qquad \qquad \qquad \Large{\textbf{or}}\)</span></p>
<ol class="arabic simple" start="2">
<li><p>Making no stops and just driving straight to the last hotel in which case the penalty is <span class="math notranslate nohighlight">\((200-a_i)^2\)</span>.</p></li>
</ol>
<p>whichever of these two options yields a lower total penalty is our solution.</p>
<p>The recurrence for this problem is thus</p>
<div class="math notranslate nohighlight">
\[
T(i) = \min\left\{ \min_j\left\{ \left(200-(a_i-a_j)\right)^2 + T(j) \right\}, \quad (200-a_i)^2 \right\}
\]</div>
<p>where <span class="math notranslate nohighlight">\(1\leq j &lt; i\)</span> and <span class="math notranslate nohighlight">\(1\leq i \leq n\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">p2</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="c1"># initialize baselines</span>
    <span class="n">sols</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;a</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">]</span> <span class="c1"># baseline for routes is we just drive straight to the last hotel with no stops</span>
    <span class="n">opt_penalties</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="mi">200</span> <span class="o">-</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">]</span> <span class="c1"># baseline for the penalty is the corresponding penalty calculated via (200-x)^2</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="mi">200</span> <span class="o">-</span> <span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">seq</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">opt_penalties</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">P</span> <span class="o">&lt;</span> <span class="n">opt_penalties</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">opt_penalties</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span>
                <span class="n">sols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sols</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span> <span class="sa">f</span><span class="s2">&quot;a</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">]</span>
    
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;Optimal stop sequence&quot;</span><span class="p">:</span> <span class="n">sols</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Sequence penalty&quot;</span><span class="p">:</span><span class="n">opt_penalties</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]}</span>

<span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">hotels</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Solution for </span><span class="si">{</span><span class="n">hotels</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">is: </span><span class="si">{</span><span class="n">p2</span><span class="p">(</span><span class="n">hotels</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">hotels</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">134</span><span class="p">,</span> <span class="mi">147</span><span class="p">,</span> <span class="mi">244</span><span class="p">,</span> <span class="mi">288</span><span class="p">,</span> <span class="mi">303</span> <span class="p">]</span>
<span class="n">func</span><span class="p">(</span><span class="n">hotels</span><span class="p">)</span>
<span class="n">hotels</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">190</span><span class="p">,</span> <span class="mi">420</span><span class="p">,</span> <span class="mi">550</span><span class="p">,</span> <span class="mi">660</span><span class="p">,</span> <span class="mi">670</span> <span class="p">]</span>
<span class="n">func</span><span class="p">(</span><span class="n">hotels</span><span class="p">)</span>
<span class="n">hotels</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">270</span><span class="p">,</span> <span class="mi">430</span><span class="p">,</span> <span class="mi">500</span> <span class="p">]</span>
<span class="n">func</span><span class="p">(</span><span class="n">hotels</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Solution for [100, 134, 147, 244, 288, 303] 
is: {&#39;Optimal stop sequence&#39;: [&#39;a3&#39;, &#39;a6&#39;], &#39;Sequence penalty&#39;: 4745}
Solution for [190, 420, 550, 660, 670] 
is: {&#39;Optimal stop sequence&#39;: [&#39;a1&#39;, &#39;a2&#39;, &#39;a5&#39;], &#39;Sequence penalty&#39;: 3500}
Solution for [10, 200, 270, 430, 500] 
is: {&#39;Optimal stop sequence&#39;: [&#39;a3&#39;, &#39;a5&#39;], &#39;Sequence penalty&#39;: 5800}
</pre></div>
</div>
</div>
</div>
<p>The time complexity of this algorithm is <span class="math notranslate nohighlight">\(O(n^2)\)</span> due to the doubly nested loops. It is possibly to get this down to <span class="math notranslate nohighlight">\(O(n\log_2{n})\)</span> if we utilize a binary search to speed up the inner loop. We can utilize binary search since the hotels are sorted in order of increasing distance from the starting point. The space complexity is also <span class="math notranslate nohighlight">\(O(n^2)\)</span> since we are storing the solution sequence for each subproblem meaning we will be storing arrays with <span class="math notranslate nohighlight">\(O(i)\)</span> elements for each subproblem meaning in total we store at most</p>
<div class="math notranslate nohighlight">
\[
\sum_{i=1}^{n}i
\]</div>
<p>elements in memory. This is an arithmetic series whose sum is well known to be equal to</p>
<div class="math notranslate nohighlight">
\[
\frac{n(a_1+a_n)}{2}
\]</div>
<p>where <span class="math notranslate nohighlight">\(a_1\)</span> and <span class="math notranslate nohighlight">\(a_n\)</span> are the first and last terms in the series respectively which means this sum is equal to <span class="math notranslate nohighlight">\(n(1+n)/2 \in O(n^2)\)</span>.</p>
</section>
<section id="yuckdonalds">
<h3>6.3 Yuckdonald’s<a class="headerlink" href="#yuckdonalds" title="Link to this heading">#</a></h3>
<p>For subproblem <span class="math notranslate nohighlight">\(i\)</span> the solution will be either</p>
<ol class="arabic simple">
<li><p>Opening a store at only location <span class="math notranslate nohighlight">\(i\)</span> is optimal.</p></li>
</ol>
<p><span class="math notranslate nohighlight">\(\qquad \qquad \qquad \Large{\textbf{or}}\)</span></p>
<ol class="arabic simple" start="2">
<li><p>Opening a location at location <span class="math notranslate nohighlight">\(i\)</span> in addition to opening one at the optimal locations for <em>one of</em> the previous optimal solutions to the smaller subproblems is optimal. To check this we can simply loop over all previous optimal solutions and see if opening a store at location <span class="math notranslate nohighlight">\(i\)</span> in addition to the stores already open for that optimal solution will result in more profit than only opening one store at location <span class="math notranslate nohighlight">\(i\)</span>. If we find such a previous solution <span class="math notranslate nohighlight">\(L_j\)</span> then we must also check if the store at location <span class="math notranslate nohighlight">\(i\)</span> is at least <span class="math notranslate nohighlight">\(k\)</span> miles away from the store at position <span class="math notranslate nohighlight">\(j\)</span> for that optimal solution and if it is then that is our optimal solution.</p></li>
</ol>
<p>The recurrence for this problem is this</p>
<div class="math notranslate nohighlight">
\[
T(i) = \max\left\{ \max_j\left\{ p_i + T(j) \bigg\vert m_i-m_j \geq k\right\}, \quad p_i\right\}
\]</div>
<p>where <span class="math notranslate nohighlight">\(1\leq j &lt; i\)</span> and <span class="math notranslate nohighlight">\(1\leq i \leq n\)</span>.</p>
<p>For completeness, we will define our base case as</p>
<div class="math notranslate nohighlight">
\[
T(0)=0.
\]</div>
<p>Since we are requiring that restaurant <span class="math notranslate nohighlight">\(i\)</span> be built at each subproblem of size <span class="math notranslate nohighlight">\(i\)</span>, similar to LCS, the solution to our problem will be the maximum value in the table once it is built not necessarily the last element in the table.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">p3</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">]</span> <span class="c1"># set the baseline to all 0</span>
    <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># for subproblem 1 the optimal solution is trivial: open a location at location 1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">T</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>
               <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">T</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
               
    <span class="c1"># the max between 0 and max(T) is meant to incorporate the base case T(0)=0 without </span>
    <span class="c1"># having to put it in the loop and mess with indexes</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">T</span><span class="p">))</span> 

<span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Maximum profit for </span><span class="se">\n</span><span class="s2">m=</span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">p=</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">k=</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">is: </span><span class="si">{</span><span class="n">p3</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Test cases from: https://gist.github.com/primaryobjects/1406b79f12db5320f0797792d8f73b04</span>
<span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">func</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">k</span><span class="o">=</span><span class="mi">5</span>
<span class="n">func</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span> <span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span> <span class="p">]</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">func</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span> <span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">31</span> <span class="p">]</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">func</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Maximum profit for 
m=[1, 2, 3, 4, 5, 6] 
p=[5, 5, 5, 5, 5, 5] 
k=5 
is: 10
Maximum profit for 
m=[0, 5, 10, 15, 20] 
p=[5, 5, 5, 5, 5] 
k=5 
is: 25
Maximum profit for 
m=[10, 20, 25, 30, 40] 
p=[100, 100, 101, 100, 100] 
k=10 
is: 400
Maximum profit for 
m=[0, 4, 8] 
p=[10, 42, 31] 
k=5 
is: 42
</pre></div>
</div>
</div>
</div>
<p>The time and space complexity are clearly <span class="math notranslate nohighlight">\(O(n^2)\)</span> and <span class="math notranslate nohighlight">\(O(n)\)</span> respectively. As a sanity check we can code a brute force algorithm to compute the answer of our test cases shown below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">p3_brute_force</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="c1"># Initialize the maximum profit</span>
    <span class="n">max_profit</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># Iterate over all subsets of the locations</span>
    <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">):</span>  <span class="c1"># 2^n possible subsets</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">total_profit</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">last_location</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>  <span class="c1"># Initialize last location as negative infinity</span>
        
        <span class="c1"># Check each location in the subset</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># If the i-th bit is set in the subset, location i is included</span>
            <span class="k">if</span> <span class="n">subset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">):</span>
                <span class="c1"># Check if this location satisfies the distance constraint</span>
                <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">last_location</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>
                    <span class="n">total_profit</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># Add the profit of location i</span>
                    <span class="n">last_location</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># Update last location</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>  <span class="c1"># Subset is invalid, so break out of loop</span>
        
        <span class="c1"># If the subset is valid and its profit is greater than the current max, update max_profit</span>
        <span class="k">if</span> <span class="n">valid</span><span class="p">:</span>
            <span class="n">max_profit</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_profit</span><span class="p">,</span> <span class="n">total_profit</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">max_profit</span>


<span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">5</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Maximum profit for test case 1 is: </span><span class="si">{</span><span class="n">p3_brute_force</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">),</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">k</span><span class="o">=</span><span class="mi">5</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Maximum profit for test case 2 is: </span><span class="si">{</span><span class="n">p3_brute_force</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">),</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span> <span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span> <span class="p">]</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">10</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Maximum profit for test case 3 is: </span><span class="si">{</span><span class="n">p3_brute_force</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">),</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span> <span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">31</span> <span class="p">]</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">5</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Maximum profit for test case 4 is: </span><span class="si">{</span><span class="n">p3_brute_force</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">),</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Maximum profit for test case 1 is: 10

Maximum profit for test case 2 is: 25

Maximum profit for test case 3 is: 400

Maximum profit for test case 4 is: 42
</pre></div>
</div>
</div>
</div>
<p>Let’s add even more test cases just to make sure</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">uniform</span><span class="p">,</span> <span class="n">randint</span>


<span class="n">test_cases</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="p">[</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">)):</span> <span class="c1"># to ensure distances increase</span>
        <span class="n">m</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">uniform</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">5</span><span class="p">))</span> <span class="p">)</span>
    
    <span class="n">p</span> <span class="o">=</span> <span class="p">[</span>  <span class="nb">int</span><span class="p">(</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">8</span><span class="p">))</span>  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>  <span class="p">]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
    <span class="n">test_cases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>  <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="p">)</span>


<span class="k">for</span> <span class="n">tst</span> <span class="ow">in</span> <span class="n">test_cases</span><span class="p">:</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">tst</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">p3_brute_force</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="n">p3</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="c1">#print(f&quot;Passes with max profit: {p3(m, p, k)} with m = {m}, p={p} and k={k}&quot;)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed for test case: </span><span class="si">{</span><span class="n">tst</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="dictionary-lookup">
<h3>6.4 Dictionary lookup<a class="headerlink" href="#dictionary-lookup" title="Link to this heading">#</a></h3>
<p>So let’s define our subproblem in words first:</p>
<p><span class="math notranslate nohighlight">\(T(i)\)</span> is <span class="math notranslate nohighlight">\(\text{True}\)</span> if the substring <span class="math notranslate nohighlight">\(s[1...i]\)</span> can be broken up into a sequence of valid words from our dictionary <span class="math notranslate nohighlight">\(D\)</span> and is <span class="math notranslate nohighlight">\(\text{False}\)</span> otherwise.</p>
<p>If we want to evaluate <span class="math notranslate nohighlight">\(T(i)\)</span> and have found the solution for all subproblems of size <span class="math notranslate nohighlight">\(&lt;i\)</span> how would we do it? Well if the substring <span class="math notranslate nohighlight">\(s[1...i]\)</span> can be broken into a sequence of valid words there will be some breaking point <span class="math notranslate nohighlight">\(j&lt;i\)</span> where the substring <span class="math notranslate nohighlight">\(s[1...j]\)</span> will be able to be broken into a sequence of valid words and thus <span class="math notranslate nohighlight">\(T(j)=\text{True}\)</span> and the remaining part of the string <span class="math notranslate nohighlight">\(s[j+1...i]\)</span> will be a word from <span class="math notranslate nohighlight">\(D\)</span>. We should also check if the whole substring <span class="math notranslate nohighlight">\(s[1...i]\)</span> is in <span class="math notranslate nohighlight">\(D\)</span> which would mean there are no breaking points.</p>
<p>With this in mind for the recurrence lets try:</p>
<div class="math notranslate nohighlight">
\[
T(i) = \bigvee_{j=0}^{i-1} (T(j) \wedge s[j+1...i] \in D) \quad \text{where} \quad 1\leq i \leq n
\]</div>
<p>With the base case <span class="math notranslate nohighlight">\(T(0)=\text{True}\)</span> which will enable us to first check if the whole substring <span class="math notranslate nohighlight">\(s[1...i]\)</span> is in <span class="math notranslate nohighlight">\(D\)</span> since the first term in the clause, i.e. <span class="math notranslate nohighlight">\(T(0) \wedge s[1...i] \in D\)</span>, will now evaluate to <span class="math notranslate nohighlight">\(\text{True}\)</span> only if the whole substring is in <span class="math notranslate nohighlight">\(D\)</span>.</p>
<p>Note that the <span class="math notranslate nohighlight">\(\bigvee\)</span> means we perform an OR over the AND clauses</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
&amp;\bigvee_{j=0}^{i-1} (T(j) \wedge s[j+1...i] \in D) \\
&amp;= (T(0) \wedge s[1...i] \in D) \vee (T(1) \wedge s[2...i] \in D) \vee \cdots \vee (T(i-1) \wedge s[i...i] \in D)
\end{align*}
\end{split}\]</div>
<p>so if any one of them is <span class="math notranslate nohighlight">\(\text{True}\)</span> the whole expression evaluates to <span class="math notranslate nohighlight">\(\text{True}\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># We use j-1 because python indexing starts at 0 instead of 1,</span>
<span class="c1"># but note that we dont use i+1 when indexing s despite this because we are starting i at 1 in the outer loop</span>
<span class="k">def</span> <span class="nf">p4</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">D</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># base case</span>
    <span class="n">back</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span> <span class="c1"># for backtracking</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> 
            <span class="n">substr</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">]</span> 
            <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="p">(</span> <span class="n">T</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">substr</span> <span class="ow">in</span> <span class="n">D</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">back</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
    
    <span class="k">if</span> <span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># if string can be broken into words perform backtracking to find words</span>
        <span class="n">words</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">start_break</span> <span class="o">=</span> <span class="n">back</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">back</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">end_break</span> <span class="o">=</span> <span class="n">back</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">words</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">end_break</span><span class="p">:</span><span class="n">start_break</span><span class="p">]</span> <span class="o">+</span> <span class="n">words</span>
                <span class="n">start_break</span> <span class="o">=</span> <span class="n">end_break</span>
        <span class="n">words</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">start_break</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">words</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">&#39; can be broken up into: &#39;</span><span class="si">{</span><span class="n">words</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


<span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">D</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can &#39;</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">&#39; be broken into a sequence of valid words from </span><span class="si">{</span><span class="n">D</span><span class="si">}</span><span class="s2">? </span><span class="si">{</span><span class="s1">&#39;yes&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">p4</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">)</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;no&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;leetcode&quot;</span>
<span class="n">D</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;leet&quot;</span><span class="p">,</span><span class="s2">&quot;code&quot;</span><span class="p">]</span>
<span class="n">func</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;itwasthebestoftimes&quot;</span>
<span class="n">D</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;it&quot;</span><span class="p">,</span><span class="s2">&quot;was&quot;</span><span class="p">,</span><span class="s2">&quot;the&quot;</span><span class="p">,</span><span class="s2">&quot;best&quot;</span><span class="p">,</span><span class="s2">&quot;of&quot;</span><span class="p">,</span><span class="s2">&quot;times&quot;</span><span class="p">]</span>
<span class="n">func</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;ab&quot;</span>
<span class="n">D</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="s2">&quot;b&quot;</span><span class="p">]</span>
<span class="n">func</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;leetcode&#39; can be broken up into: &#39;leet  code&#39;
Can &#39;leetcode&#39; be broken into a sequence of valid words from [&#39;leet&#39;, &#39;code&#39;]? yes
&#39;itwasthebestoftimes&#39; can be broken up into: &#39;it  was the best of times&#39;
Can &#39;itwasthebestoftimes&#39; be broken into a sequence of valid words from [&#39;it&#39;, &#39;was&#39;, &#39;the&#39;, &#39;best&#39;, &#39;of&#39;, &#39;times&#39;]? yes
&#39;ab&#39; can be broken up into: &#39;a  b&#39;
Can &#39;ab&#39; be broken into a sequence of valid words from [&#39;a&#39;, &#39;b&#39;]? yes
</pre></div>
</div>
</div>
</div>
<p>The problem says to assume checking if a word is in the dictionary <span class="math notranslate nohighlight">\(D\)</span> is an <span class="math notranslate nohighlight">\(O(1)\)</span> time operation so the time complexity of this algorithm is <span class="math notranslate nohighlight">\(O(n^2)\)</span>. If the dictionary lookups were not constant time but instead <span class="math notranslate nohighlight">\(O(n)\)</span> time then the time complexity would be <span class="math notranslate nohighlight">\(O(n^3)\)</span>.</p>
</section>
<section id="trinary-multiplication">
<h3>6.6 Trinary multiplication<a class="headerlink" href="#trinary-multiplication" title="Link to this heading">#</a></h3>
<p>This problem seems similar to chain matrix multiplication.</p>
</section>
<section id="longest-palindromic-subsequence">
<h3>6.7 Longest palindromic subsequence<a class="headerlink" href="#longest-palindromic-subsequence" title="Link to this heading">#</a></h3>
<p>Given a sequence</p>
<div class="math notranslate nohighlight">
\[
X_n = a_1,a_2,a_3...,a_n
\]</div>
<p>let’s define <span class="math notranslate nohighlight">\(Y_n\)</span> as</p>
<div class="math notranslate nohighlight">
\[
Y_n = a_n,a_{n-1},a_{n-2},...,a_1
\]</div>
<p>That is <span class="math notranslate nohighlight">\(Y_n\)</span> is the reverse of the string <span class="math notranslate nohighlight">\(X_n\)</span>. The longest common subsequence between <span class="math notranslate nohighlight">\(X_n\)</span> and <span class="math notranslate nohighlight">\(Y_n\)</span> will be our longest common palindromic subsequence of <span class="math notranslate nohighlight">\(X_n\)</span>. Think about it; it’s true.</p>
<p>The recurrence is thus</p>
<div class="math notranslate nohighlight">
\[\begin{split}
L_{i,j} = \begin{cases}
\max\{L_{i,j-1}, L_{i-1,j}\} &amp;\quad \text{if} \quad x_i\not=y_j\\
L_{i-1,j-1}+1 &amp;\quad \text{if} \quad x_i=y_j
\end{cases} \quad \text{where} \quad 1\leq i\leq n, \quad  1\leq j\leq m
\end{split}\]</div>
<p>The base cases are</p>
<div class="math notranslate nohighlight">
\[\begin{split}
L_{i,0} = 0 \quad \text{where} \quad 1\leq i\leq n \\
L_{0,j} = 0 \quad \text{where} \quad  1\leq j\leq m
\end{split}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">p7</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
</div>
</div>
<p>The complexity is clearly <span class="math notranslate nohighlight">\(O(nm)\)</span> as there are <span class="math notranslate nohighlight">\(nm\)</span> table entries and it takes <span class="math notranslate nohighlight">\(O(1)\)</span> time to fill in/compute each one.</p>
</section>
<section id="longest-common-substring">
<h3>6.8 Longest common substring<a class="headerlink" href="#longest-common-substring" title="Link to this heading">#</a></h3>
<p>Since we must find the longest common <em>substring</em> this means the subsequences must be <em>contiguous</em>. This means when we encounter a pair of elements that don’t match we simply reset the length of the LCS to 0 instead of taking the max of one of the solutions to the two smaller subproblems <span class="math notranslate nohighlight">\(X_{1:i-1},Y_{1:j}\)</span> and <span class="math notranslate nohighlight">\(X_{1:i},Y_{1:j-1}\)</span>.</p>
<p>The recurrence for this problem is thus:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
L_{i,j} = \begin{cases}
0 &amp;\quad \text{if} \quad x_i\not=y_j\\
L_{i-1,j-1}+1 &amp;\quad \text{if} \quad x_i=y_j
\end{cases} \quad \text{where} \quad 1\leq i\leq n, \quad  1\leq j\leq m
\end{split}\]</div>
<p>The base cases are</p>
<div class="math notranslate nohighlight">
\[\begin{split}
L_{i,0} = 0 \quad \text{where} \quad 1\leq i\leq n \\
L_{0,j} = 0 \quad \text{where} \quad  1\leq j\leq m
\end{split}\]</div>
<p>Note that in this case we must return the maximum element in the table not just the bottom corner element of the table since we could have <span class="math notranslate nohighlight">\(x_n\not=y_n\)</span> in which case the bottom corner element would be 0 but there could be another element which is not <span class="math notranslate nohighlight">\(0\)</span> in the previous entries of the table.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">p8</span><span class="p">(</span><span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span><span class="p">):</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
   
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span> <span class="p">[</span> <span class="nb">max</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The complexity is clearly <span class="math notranslate nohighlight">\(O(nm)\)</span> as there are <span class="math notranslate nohighlight">\(nm\)</span> table entries and it takes <span class="math notranslate nohighlight">\(O(1)\)</span> time to fill in/compute each one.</p>
</section>
<section id="id15">
<h3>6.11 Longest common subsequence<a class="headerlink" href="#id15" title="Link to this heading">#</a></h3>
<p>Already solved above!</p>
</section>
<section id="making-change">
<h3>6.17 Making change<a class="headerlink" href="#making-change" title="Link to this heading">#</a></h3>
<p>I think we have to assume all the inputs will be integers as we did with knapsack otherwise I’m not sure how to handle a table where one of the indices is a continuous value. This problem seems similar to knapsack with repetition since we have an unlimited supply of each denomination. I think we can either define the subproblems in terms of either a smaller subset of the possible coins, e.g. <span class="math notranslate nohighlight">\(T(i)\)</span> is the boolean value corresponding to whether or not we can make change for <span class="math notranslate nohighlight">\(v\)</span> using a subset of coins of denomination <span class="math notranslate nohighlight">\(X_i=\{x_1,...,x_i\}\)</span>, or in terms of smaller values of <span class="math notranslate nohighlight">\(v\)</span>, e.g. <span class="math notranslate nohighlight">\(T(i)\)</span> is the boolean value corresponding to whether or not we can make change for <span class="math notranslate nohighlight">\(0\leq i\leq v\)</span> using  the full set of coins of denomination <span class="math notranslate nohighlight">\(X=\{x_1,...,x_n\}\)</span>. The latter seems most straightforward to me in terms of how we could use solutions to smaller subproblems to find solutions to larger ones. For example suppose we want to see if we can make change for <span class="math notranslate nohighlight">\(i\)</span> and we have determined whether we can make change or not for all values <span class="math notranslate nohighlight">\(&lt;i\)</span>. We can</p>
<ol class="arabic simple">
<li><p>Look to see if there is a coin with denomination <span class="math notranslate nohighlight">\(i\)</span> in <span class="math notranslate nohighlight">\(X\)</span> and if so return <span class="math notranslate nohighlight">\(\text{True}\)</span>.</p></li>
</ol>
<p>or</p>
<ol class="arabic simple" start="2">
<li><p>Look to see if we can make change for <span class="math notranslate nohighlight">\(i-1\)</span> and <span class="math notranslate nohighlight">\(1\)</span> and if so then we return <span class="math notranslate nohighlight">\(\text{True}\)</span> if not then we return <span class="math notranslate nohighlight">\(\text{False}\)</span> and see if we can instead make change for <span class="math notranslate nohighlight">\(i-2\)</span> and <span class="math notranslate nohighlight">\(2\)</span> and so on until we’ve tried up to <span class="math notranslate nohighlight">\(i-(i-1)\)</span> and <span class="math notranslate nohighlight">\(i-1\)</span>. If <em>any one</em> of these is <span class="math notranslate nohighlight">\(\text{True}\)</span> then we can in fact make change for <span class="math notranslate nohighlight">\(i\)</span> so we will return <span class="math notranslate nohighlight">\(\text{True}\)</span>.</p></li>
</ol>
<p>Thus we can use following recurrence to describe this problem:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
T(i) = \left(\bigvee_{j} [T(i-j) \wedge T(j)]\right) \vee \alpha(i)\\
\text{where} \quad 2 \leq i \leq v, \quad 1 \leq j &lt; i \quad \text{and} \\
\alpha(i)=\begin{cases} 
      \text{True} &amp;\quad\text{if}\quad i \in X\\
      \text{False}  &amp;\quad\text{otherwise} \\
   \end{cases}
\end{split}\]</div>
<p>and the base cases are <span class="math notranslate nohighlight">\(T(0)=\text{True}\)</span>, since we can always make change for nothing, and</p>
<div class="math notranslate nohighlight">
\[\begin{split}T(1)=\begin{cases} 
      \text{True} &amp;\quad\text{if}\quad 1 \in X\\
      \text{False}  &amp;\quad\text{otherwise} \\
   \end{cases}\\
\end{split}\]</div>
<p>Note that the <span class="math notranslate nohighlight">\(\bigvee\)</span> means we perform an OR over the AND clauses</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
&amp;\bigvee_{j=0}^i T(i-j) \wedge T(j) \\
&amp;= (T(i) \wedge T(0)) \vee (T(i-1) \wedge T(1)) \vee \cdots \vee (T(0) \wedge T(i))
\end{align*}
\end{split}\]</div>
<p>so if any one of them is <span class="math notranslate nohighlight">\(\text{True}\)</span> the whole expression evaluates to <span class="math notranslate nohighlight">\(\text{True}\)</span>. And in fact we actually just need to let <span class="math notranslate nohighlight">\(j\)</span> run from 1 to at most <span class="math notranslate nohighlight">\(\left\lceil\frac{i}{2}\right\rceil\)</span> due to the symmetric nature of the AND clause (notice the first and last terms of the clause are logically equivalent <span class="math notranslate nohighlight">\(T(i) \wedge T(0) = T(0) \wedge T(i)\)</span>).</p>
<p>For each value of <span class="math notranslate nohighlight">\(i\)</span> we solve for we have to examine all elements in the set <span class="math notranslate nohighlight">\(X=\{x_1,...,x_n\}\)</span> and there are <span class="math notranslate nohighlight">\(v\)</span> values of <span class="math notranslate nohighlight">\(i\)</span> so our time complexity is <span class="math notranslate nohighlight">\(O(nv)\)</span>. Note that like knapsack this is exponential in <em>the number of bits</em> needed to represent <span class="math notranslate nohighlight">\(v\)</span> i.e. <span class="math notranslate nohighlight">\(\log_2{v}\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">p17</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># edge cases</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">X</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">X</span> <span class="c1"># baseline is: is there a coin with denomination i in X? Complexity is O(n)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="p">(</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">T</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span>
    
    <span class="c1"># TODO Implement backtracing</span>

    <span class="k">return</span> <span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">X</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can we make change for </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> using </span><span class="si">{</span><span class="n">X</span><span class="si">}</span><span class="s2">? </span><span class="si">{</span><span class="s1">&#39;yes&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">p17</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">)</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;no&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">v</span> <span class="o">=</span> <span class="mi">77</span>
<span class="n">func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="n">v</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="n">v</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="n">v</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="n">v</span> <span class="o">=</span> <span class="mi">25</span>
<span class="n">func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="n">v</span> <span class="o">=</span> <span class="mi">25</span>
<span class="n">func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Can we make change for 77 using [1, 4, 6, 8, 3]? yes
Can we make change for 7 using [2, 8, 9]? no
Can we make change for 15 using [5, 10]? yes
Can we make change for 12 using [5, 10]? no
Can we make change for 25 using [5, 10]? yes
Can we make change for 25 using [5]? yes
</pre></div>
</div>
</div>
</div>
</section>
<section id="making-change-2">
<h3>6.18 Making change 2<a class="headerlink" href="#making-change-2" title="Link to this heading">#</a></h3>
<p>Now for this variation of the problem we can use each coin <em>at most once</em> so it is similar to knapsack without repetition.</p>
<p>For our subproblem lets define it as:</p>
<p><span class="math notranslate nohighlight">\(T(i,s)\)</span> is <span class="math notranslate nohighlight">\(\text{True}\)</span> if we can make change for <span class="math notranslate nohighlight">\(0\leq s \leq v\)</span> using the first <span class="math notranslate nohighlight">\(0\leq i \leq n\)</span> coins <span class="math notranslate nohighlight">\(X_i=\{x_1,...,x_i\}\)</span> using each coin at most once and is <span class="math notranslate nohighlight">\(\text{False}\)</span> otherwise.</p>
<p>For the coin <span class="math notranslate nohighlight">\(x_i\)</span>, if <span class="math notranslate nohighlight">\(x_i\leq s\)</span>, there are two options</p>
<ol class="arabic simple">
<li><p>We use <span class="math notranslate nohighlight">\(x_i\)</span> in our change and thus need to use the first <span class="math notranslate nohighlight">\(i-1\)</span> coins to make change for <span class="math notranslate nohighlight">\(s-x_i\)</span> so we check the truth value of entry <span class="math notranslate nohighlight">\(K(i-1,s-x_i)\)</span>.</p></li>
</ol>
<p>or</p>
<ol class="arabic simple" start="2">
<li><p>We do not use <span class="math notranslate nohighlight">\(x_i\)</span> and thus must use the first <span class="math notranslate nohighlight">\(i-1\)</span> coins to make change for <span class="math notranslate nohighlight">\(s\)</span> without <span class="math notranslate nohighlight">\(x_i\)</span> in which case we check the truth value of the entry <span class="math notranslate nohighlight">\(K(i-1,s)\)</span>.</p></li>
</ol>
<p>And if <span class="math notranslate nohighlight">\(x_i&gt;s\)</span> then we can’t include <span class="math notranslate nohighlight">\(x_i\)</span> so we must use the first <span class="math notranslate nohighlight">\(i-1\)</span> coins to make change for <span class="math notranslate nohighlight">\(s\)</span> so we look at the truth value of the entry <span class="math notranslate nohighlight">\(K(i-1,s)\)</span>.</p>
<p>The following is the recurrence:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
T(i,s) = \begin{cases}
T(i-1, s-x_i) \vee T(i-1, s) &amp; \quad \text{if} \quad  x_i \leq s \\
T(i-1, s) &amp; \quad \text{if} \quad x_i &gt; s
\end{cases}
\end{split}\]</div>
<p>with the base cases being</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
T(0,0) &amp;= \text{True} \\
T(0,s) &amp;= \text{False} \quad \text{where} \quad 0 &lt; s \leq v \\
T(i,0) &amp;= \text{True} \quad \text{where} \quad 0 &lt; i \leq n \\
\end{align*}
\end{split}\]</div>
<p>The first base case follows because we can make change for <span class="math notranslate nohighlight">\(0\)</span> given a set of <span class="math notranslate nohighlight">\(0\)</span> coins. The second base case follows because we can not make change for <span class="math notranslate nohighlight">\(s&gt;0\)</span> given <span class="math notranslate nohighlight">\(0\)</span> coins. The third base case comes from the fact that we can always make change for a value of <span class="math notranslate nohighlight">\(v=0\)</span> given any set of coins since we just need to use the empty set. Our answer will be given by <span class="math notranslate nohighlight">\(T(n,v)\)</span> and our time complexity is <span class="math notranslate nohighlight">\(O(nv)\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">p18</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
    
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># will be an (n+1) by (v+1) table +1 to account for v=0 and X={}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># set base cases</span>
        <span class="n">T</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># we can always make change for nothing (s=0)</span>
               <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># we can always make change for nothing (s=0)</span>
               <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># we can never make change for s&gt;0 given no coins</span>
               <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># set non-base case entires to None</span>
               <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> 


    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">x_i</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x_i</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="p">:</span>
                <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">s</span><span class="o">-</span><span class="n">x_i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">s</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">x_i</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">:</span>
                <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">s</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>

<span class="c1"># lambda func to print output of test cases</span>
<span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">X</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can we make change for </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> using each coin at most once from </span><span class="si">{</span><span class="n">X</span><span class="si">}</span><span class="s2">? </span><span class="si">{</span><span class="s1">&#39;yes&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">p18</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">)</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;no&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="n">v</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="c1"># can make change if we can use each coin as many times as we want but not at most once</span>
<span class="n">v</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span> <span class="c1"># can make change using 8+2+5</span>
<span class="n">v</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="c1"># can make change using 8+2+5</span>
<span class="n">v</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span> <span class="c1"># from the book</span>
<span class="n">v</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span> <span class="c1"># from the book</span>
<span class="n">v</span> <span class="o">=</span> <span class="mi">31</span>
<span class="n">func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span> <span class="c1"># from the book</span>
<span class="n">v</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">func</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Can we make change for 12 using each coin at most once from [5, 10]? no
Can we make change for 15 using each coin at most once from [5]? no
Can we make change for 15 using each coin at most once from [5, 2, 8]? yes
Can we make change for 15 using each coin at most once from [5, 2, 8, 2]? yes
Can we make change for 16 using each coin at most once from [1, 5, 10, 20]? yes
Can we make change for 31 using each coin at most once from [1, 5, 10, 20]? yes
Can we make change for 40 using each coin at most once from [1, 5, 10, 20]? no
</pre></div>
</div>
</div>
</div>
</section>
<section id="making-change-3">
<h3>6.19 Making change 3<a class="headerlink" href="#making-change-3" title="Link to this heading">#</a></h3>
<p>In this variation of the problem we again have an unlimited number of each coin in <span class="math notranslate nohighlight">\(X=\{x_1,...x_n\}\)</span> but we can use <em>at most</em> <span class="math notranslate nohighlight">\(k\)</span> coins total to make change for <span class="math notranslate nohighlight">\(v\)</span>. The problem says to give an <em>efficient</em> dynamic programming algorithm for this problem which leads me to think that we can’t have a complexity that depends on <span class="math notranslate nohighlight">\(v\)</span> (or grows faster than logarithmically in <span class="math notranslate nohighlight">\(v\)</span>) like we did for the other two variations.</p>
<p><span class="math notranslate nohighlight">\(T(i,j)\)</span> is <span class="math notranslate nohighlight">\(\text{True}\)</span> if we can make change for <span class="math notranslate nohighlight">\(v\)</span> using <em>exactly</em> <span class="math notranslate nohighlight">\(j\)</span> coins from <span class="math notranslate nohighlight">\(X_i=\{x_1,\dots,x_i\}\)</span> and <span class="math notranslate nohighlight">\(\text{False}\)</span> otherwise.</p>
</section>
<section id="optimal-binary-search-trees">
<h3>6.20 Optimal binary search trees<a class="headerlink" href="#optimal-binary-search-trees" title="Link to this heading">#</a></h3>
</section>
<section id="sequence-alignment">
<h3>6.26 Sequence alignment<a class="headerlink" href="#sequence-alignment" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">load_ext</span> watermark
<span class="o">%</span><span class="k">watermark</span> -n -u -v -iv
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Last updated: Sat Sep 07 2024

Python implementation: CPython
Python version       : 3.10.12
IPython version      : 8.22.2

sympy: 1.12
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./computerscience/algorithms"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="divide_conquer.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Divide &amp; conquer</p>
      </div>
    </a>
    <a class="right-next"
       href="graph_algos.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Graph algorithms</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bottom-up-versus-top-down-approaches">Bottom-up versus top-down approaches</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#n-th-fibonacci-number"><span class="math notranslate nohighlight">\(n\)</span>-th Fibonacci number</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rod-cutting">Rod cutting</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#top-down-approach">Top-down approach</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mathematical-reasoning-for-solution">Mathematical reasoning for solution</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bottom-up-approach">Bottom-up approach</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#longest-increasing-subsequence">Longest increasing subsequence</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#potential-solution">Potential solution</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#key-insight">Key Insight</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-analysis">Complexity analysis</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#longest-common-subsequence">Longest common subsequence</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#determining-subproblem-structure">Determining subproblem structure</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#knapsack">Knapsack</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#no-repetition">No repetition</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#better-subproblem-definition">Better subproblem definition</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity">Complexity</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#with-repetition">With repetition</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#chain-matrix-multiplication">Chain matrix multiplication</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">Bottom-up approach</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#characterize-the-structure-of-an-optimal-solution-parenthesization">1. Characterize the structure of an optimal solution (parenthesization)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#recursively-define-the-value-of-an-optimal-solution">2. Recursively define the value of an optimal solution</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#shortest-paths">Shortest paths</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#practice-problems">Practice problems</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#maximal-contiguous-subsequence">6.1 Maximal Contiguous Subsequence</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hotel-stops">6.2 Hotel Stops</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#yuckdonalds">6.3 Yuckdonald’s</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dictionary-lookup">6.4 Dictionary lookup</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#trinary-multiplication">6.6 Trinary multiplication</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#longest-palindromic-subsequence">6.7 Longest palindromic subsequence</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#longest-common-substring">6.8 Longest common substring</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">6.11 Longest common subsequence</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#making-change">6.17 Making change</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#making-change-2">6.18 Making change 2</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#making-change-3">6.19 Making change 3</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#optimal-binary-search-trees">6.20 Optimal binary search trees</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sequence-alignment">6.26 Sequence alignment</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Amanuel Anteneh
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>